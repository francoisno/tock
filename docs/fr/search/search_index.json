{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenue sur Tock : une plateforme conversationnelle ouverte Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur https://github.com/voyages-sncf-technologies/tock sous une licence Apache 2 . Fonctionnalit\u00e9s Bots autonomes ou int\u00e9gr\u00e9s \u00e0 des canaux externes comme des sites Web, applications mobiles, r\u00e9seaux sociaux Plateforme NLU (Natural Language Understanding) compl\u00e8te : Compatible avec des biblioth\u00e8ques d'algorithmes comme Apache OpenNLP , Stanford CoreNLP , Duckling . D\u00e9ployable seule, pour des cas d'usage comme l' Internet des objets par exemple Interfaces Tock Studio : Qualifier les phrases, g\u00e9rer les mod\u00e8les et l'apprentissage du bot, cr\u00e9er des parcours conversationnels sans code ni connaissance pouss\u00e9e des algorithmes Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations, performances et erreurs (am\u00e9lioration continue des mod\u00e8les) Analyse et visualisation interactive des parcours possibles et r\u00e9ellement suivis par les utilisateurs ( Bot Flow ) Possibilit\u00e9 de d\u00e9velopper des parcours complexes et int\u00e9grer des API tierces gr\u00e2ce \u00e0 plusieurs frameworks disponibles : clients et DSL (Domain Specific Language) en Kotlin ou Bot API pour tout langage Nombreux connecteurs pour int\u00e9grer un bot \u00e0 des canaux comme Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat D\u00e9ploiement : local, cloud , on-premise , avec ou sans Docker , voire sans connexion Internet (bot \"embarqu\u00e9\" ) Technologies La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Des biblioth\u00e8ques et algorithmes NLU comme Apache OpenNLP ou Stanford CoreNLP peuvent \u00eatre utilis\u00e9es, mais Tock n'en d\u00e9pend pas directement. Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript . D\u00e9marrer... Guides et plateforme de d\u00e9monstration Manuel utilisateur (fonctionnalit\u00e9s, architecture et d\u00e9ploiement) Etudes de cas Pr\u00e9sentations et video Exemples de code Pourquoi Tock ? Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot et d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 des assistants conversationnels SNCF (pour les clients comme en interne) se sont cr\u00e9\u00e9es et utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin pour des plateformes conversationnelles et IA ouvertes, permettant de nombreux sc\u00e9narios techniques et m\u00e9tier tout en restant en ma\u00eetrise du code, l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es. L'ensemble est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants.","title":"Vue d`ensemble"},{"location":"#bienvenue-sur-tock-une-plateforme-conversationnelle-ouverte","text":"Tock ( The Open Conversation Kit ) est une plateforme compl\u00e8te pour construire des agents conversationnels - souvent appel\u00e9s bots . Contrairement \u00e0 la plupart des solutions conversationnelles, Tock ne d\u00e9pend pas d'API tierces, bien qu'il soit possible d'en int\u00e9grer. L'utilisateur choisit les composants qu'il embarque et peut ainsi conserver la ma\u00eetrise de ses mod\u00e8les et donn\u00e9es conversationnelles. Tock est utilis\u00e9 en production depuis plusieurs ann\u00e9es par OUI.sncf pour proposer des assistants sur des canaux propres (Web, mobile), r\u00e9seaux sociaux et enceintes connect\u00e9es. L'ensemble du code source est disponible sur https://github.com/voyages-sncf-technologies/tock sous une licence Apache 2 .","title":"Bienvenue sur Tock : une plateforme conversationnelle ouverte"},{"location":"#fonctionnalites","text":"Bots autonomes ou int\u00e9gr\u00e9s \u00e0 des canaux externes comme des sites Web, applications mobiles, r\u00e9seaux sociaux Plateforme NLU (Natural Language Understanding) compl\u00e8te : Compatible avec des biblioth\u00e8ques d'algorithmes comme Apache OpenNLP , Stanford CoreNLP , Duckling . D\u00e9ployable seule, pour des cas d'usage comme l' Internet des objets par exemple Interfaces Tock Studio : Qualifier les phrases, g\u00e9rer les mod\u00e8les et l'apprentissage du bot, cr\u00e9er des parcours conversationnels sans code ni connaissance pouss\u00e9e des algorithmes Support de l'internationalisation ( i18n ) pour les bots multilingues Suivi des conversations, performances et erreurs (am\u00e9lioration continue des mod\u00e8les) Analyse et visualisation interactive des parcours possibles et r\u00e9ellement suivis par les utilisateurs ( Bot Flow ) Possibilit\u00e9 de d\u00e9velopper des parcours complexes et int\u00e9grer des API tierces gr\u00e2ce \u00e0 plusieurs frameworks disponibles : clients et DSL (Domain Specific Language) en Kotlin ou Bot API pour tout langage Nombreux connecteurs pour int\u00e9grer un bot \u00e0 des canaux comme Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat D\u00e9ploiement : local, cloud , on-premise , avec ou sans Docker , voire sans connexion Internet (bot \"embarqu\u00e9\" )","title":"Fonctionnalit\u00e9s"},{"location":"#technologies","text":"La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Des biblioth\u00e8ques et algorithmes NLU comme Apache OpenNLP ou Stanford CoreNLP peuvent \u00eatre utilis\u00e9es, mais Tock n'en d\u00e9pend pas directement. Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript .","title":"Technologies"},{"location":"#demarrer","text":"Guides et plateforme de d\u00e9monstration Manuel utilisateur (fonctionnalit\u00e9s, architecture et d\u00e9ploiement) Etudes de cas Pr\u00e9sentations et video Exemples de code","title":"D\u00e9marrer..."},{"location":"#pourquoi-tock","text":"Initi\u00e9 en 2016 par l'\u00e9quipe Innovation chez OUI.sncf afin de motoriser l'analyse des commandes vocales sur ses applications mobiles , le framework fut ensuite utilis\u00e9 pour cr\u00e9er son bot Messenger , avant d'\u00eatre \u00e9tendu \u00e0 de nombreux canaux et d'accueillir d'autres bots pour de nouveaux cas d'usage. A ses d\u00e9buts, la plateforme donnait des r\u00e9sultats similaires \u00e0 ceux obtenus avec diff\u00e9rentes solutions du march\u00e9, tout en restant en ma\u00eetrise du code (embarquant des biblioth\u00e8ques opensource issues du domaine universitaire), en \u00e9vitant les effets \"bo\u00eete noire\" (notamment pour d\u00e9bugger les mod\u00e8les conversationnels) pour une r\u00e9activit\u00e9 accrue. Depuis, l'\u00e9quipe derri\u00e8re OUIbot et d'autres \u00e9quipes d\u00e9di\u00e9es \u00e0 des assistants conversationnels SNCF (pour les clients comme en interne) se sont cr\u00e9\u00e9es et utilisent quotidiennement Tock en production, tout en enrichissant r\u00e9guli\u00e8rement la plateforme de nouvelles fonctionnalit\u00e9s et connecteurs. Nous pensons qu'il y a un besoin pour des plateformes conversationnelles et IA ouvertes, permettant de nombreux sc\u00e9narios techniques et m\u00e9tier tout en restant en ma\u00eetrise du code, l'utilisateur \u00e9tant propri\u00e9taire de ses mod\u00e8les et de ses donn\u00e9es. L'ensemble est partag\u00e9 avec la communaut\u00e9 opensource dans le but de f\u00e9d\u00e9rer et mutualiser l'effort des cr\u00e9ateurs d'assistants.","title":"Pourquoi Tock ?"},{"location":"about/acknowledgments/","text":"Remerciements TODO","title":"Remerciements"},{"location":"about/acknowledgments/#remerciements","text":"TODO","title":"Remerciements"},{"location":"about/community/","text":"Contacts communaut\u00e9 Tock Pourquoi un mod\u00e8le communautaire TODO Nous contacter N'h\u00e9sitez pas \u00e0 nous contacter (cr\u00e9ateurs et communaut\u00e9 Tock) directement sur Gitter : https://gitter.im/tockchat/Lobby Vous pouvez aussi remonter une anomalie sur github : https://github.com/voyages-sncf-technologies/tock/issues","title":"Communaut\u00e9"},{"location":"about/community/#contacts-communaute-tock","text":"","title":"Contacts &amp; communaut\u00e9 Tock"},{"location":"about/community/#pourquoi-un-modele-communautaire","text":"TODO","title":"Pourquoi un mod\u00e8le communautaire"},{"location":"about/community/#nous-contacter","text":"N'h\u00e9sitez pas \u00e0 nous contacter (cr\u00e9ateurs et communaut\u00e9 Tock) directement sur Gitter : https://gitter.im/tockchat/Lobby Vous pouvez aussi remonter une anomalie sur github : https://github.com/voyages-sncf-technologies/tock/issues","title":"Nous contacter"},{"location":"about/contribute/","text":"Contribuer \u00e0 Tock Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme. Principales technologies La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9es en blocking IO , mais pour la suite l\u2019approche fibers sera privil\u00e9gi\u00e9e. Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript . Structure des sources Les d\u00e9p\u00f4ts tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es. Le d\u00e9p\u00f4t tock TODO : d\u00e9tailler les modules et la structure du repo Le d\u00e9p\u00f4t tock-docker TODO : d\u00e9tailler les modules et la structure du repo, le fonctionnement des builds Maven et Docker, etc. Construire Tock \u00e0 partir des sources Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis . Ex\u00e9cuter Tock dans un IDE Il est bien s\u00fbr possible d'ex\u00e9cuter les diff\u00e9rents composants de Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement Construire les images Docker Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t. Conventions Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock. Nous contacter Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Contribuer"},{"location":"about/contribute/#contribuer-a-tock","text":"Le projet Tock est ouvert \u00e0 la contribution et toute proposition est la bienvenue ! Cette page donne des indications sur la structure et les conventions du code de la plateforme.","title":"Contribuer \u00e0 Tock"},{"location":"about/contribute/#principales-technologies","text":"La plateforme applicative est la JVM . Le langage de r\u00e9f\u00e9rence est Kotlin mais d'autres langages de programmation peuvent \u00eatre utilis\u00e9s via les API mises \u00e0 disposition. Tock utilise Vert.x et MongoDB . Pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9es en blocking IO , mais pour la suite l\u2019approche fibers sera privil\u00e9gi\u00e9e. Les interfaces graphiques (Tock Studio) sont \u00e9crites avec Angular en Typescript .","title":"Principales technologies"},{"location":"about/contribute/#structure-des-sources","text":"","title":"Structure des sources"},{"location":"about/contribute/#les-depots","text":"tock : d\u00e9p\u00f4t principal comprend le framework et les composants de la plateforme sous licence Apache 2 . tock-corenlp : code utilisant une d\u00e9pendance optionnelle \u00e0 Stanford CoreNLP (\u00e0 la place d' Apache OpenNLP ), sous licence GPL . tock-docker : des images Docker et Docker Compose , pour faciliter la prise en main et le d\u00e9ploiement de la plateforme dans diff\u00e9rentes configurations. tock-bot-samples : des exemples de code notamment pour programmer des parcours en mode WebHook ou WebSocket comme dans les guides Tock . tock-bot-open-data : un exemple de bot bas\u00e9 sur les API Open Data de la SNCF , impl\u00e9mentant \u00e9galement des bases pour l'internationalisation avec deux langues propos\u00e9es.","title":"Les d\u00e9p\u00f4ts"},{"location":"about/contribute/#le-depot-tock","text":"TODO : d\u00e9tailler les modules et la structure du repo","title":"Le d\u00e9p\u00f4t tock"},{"location":"about/contribute/#le-depot-tock-docker","text":"TODO : d\u00e9tailler les modules et la structure du repo, le fonctionnement des builds Maven et Docker, etc.","title":"Le d\u00e9p\u00f4t tock-docker"},{"location":"about/contribute/#construire-tock-a-partir-des-sources","text":"Le projet est construit avec Maven , y compris les modules Web impliquant NPM et Angular : $ mvn package Un build d'int\u00e9gration continue est disponible sur Travis .","title":"Construire Tock \u00e0 partir des sources"},{"location":"about/contribute/#executer-tock-dans-un-ide","text":"Il est bien s\u00fbr possible d'ex\u00e9cuter les diff\u00e9rents composants de Tock (NLU, Studio, bot...) depuis un IDE comme IntelliJ , Eclipse ou Visual Studio Code par exemple. Outre les images Docker , des configurations pour IntelliJ sont fournies avec les sources de Tock : Le serveur d'administration du bot : BotAdmin Le serveur d'administration du NLP uniquement : Admin Le service NLP : NlpService Le service Duckling : Duckling Le service de construction des mod\u00e8les NLP : BuildWorker Le service de compilation des scripts : KotlinCompilerServer Pour le bot d'exemple : OpenDataBot Enfin pour lancer les interfaces d'administration, vous aurez besoin de lancer les commandes d\u00e9crites dans les liens suivants : Pour l'administration compl\u00e8te (Bot + NLP) Pour l'administration NLP uniquement","title":"Ex\u00e9cuter Tock dans un IDE"},{"location":"about/contribute/#construire-les-images-docker","text":"Les images Docker de Tock peuvent \u00eatre reconstruites \u00e0 partir des sources du d\u00e9p\u00f4t tock-docker . Pour cela, utilisez Maven qui d\u00e9clenchera le build Docker : $ mvn docker:build Vous pouvez ensuite instancier ces images via Docker ou les stacks Docker Compose avec les descripteurs \u00e0 la racine du d\u00e9p\u00f4t.","title":"Construire les images Docker"},{"location":"about/contribute/#conventions","text":"Les Kotlin Code Conventions sont utilis\u00e9es pour d\u00e9velopper le code de Tock.","title":"Conventions"},{"location":"about/contribute/#nous-contacter","text":"Un probl\u00e8me ? Une question sur l'impl\u00e9mentation ? Une id\u00e9e \u00e0 partager ? Pour contribuer au projet ou simplement en savoir plus, n'h\u00e9sitez pas \u00e0 nous contacter .","title":"Nous contacter"},{"location":"about/jobs/","text":"Emplois Tock Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page a pour but de recenser les entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste. e-voyageurs Technologie (\u00e0 l'origine de Tock) recrute des profils pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, contactez-nous sur Gitter ou sur https://jobs.oui.sncf/ .","title":"Emploi"},{"location":"about/jobs/#emplois-tock","text":"Int\u00e9ress\u00e9(e) par travailler avec Tock et contribuer \u00e0 la plateforme ? Cette page a pour but de recenser les entreprises et organisations proposants des offres d'emploi dans le domaine conversationnel avec Tock Vous utilisez Tock et proposez des offres d'emploi en conversationnel ? N'h\u00e9sitez pas \u00e0 nous le signaler pour enrichir cette liste. e-voyageurs Technologie (\u00e0 l'origine de Tock) recrute des profils pour d\u00e9velopper des assistants conversationnels avec Tock. Pour en savoir plus, contactez-nous sur Gitter ou sur https://jobs.oui.sncf/ .","title":"Emplois Tock"},{"location":"examples/presentations/","text":"Pr\u00e9sentations de Tock Quelques pr\u00e9sentations de la plateforme et du framework Tock sont list\u00e9es ci-dessous. Cela peut donner un aper\u00e7u de la solution en compl\u00e9ment des guides permettant de tester soi-m\u00eame la plateforme. N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock. Conf\u00e9rences / video D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" 30 min) Supports de pr\u00e9sentation / meetup Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource Co-d\u00e9veloppement (2017)","title":"Pr\u00e9sentations"},{"location":"examples/presentations/#presentations-de-tock","text":"Quelques pr\u00e9sentations de la plateforme et du framework Tock sont list\u00e9es ci-dessous. Cela peut donner un aper\u00e7u de la solution en compl\u00e9ment des guides permettant de tester soi-m\u00eame la plateforme. N'h\u00e9sitez pas \u00e0 partager d'autres supports et liens autour de Tock.","title":"Pr\u00e9sentations de Tock"},{"location":"examples/presentations/#conferences-video","text":"D\u00e9velopper un bot sur Messenger et Google Assistant en 30 minutes @ Devoxx France 2018 (live coding \"tools in action\" 30 min)","title":"Conf\u00e9rences / video"},{"location":"examples/presentations/#supports-de-presentation-meetup","text":"Tock - The Open Conversation Kit @ Meetup Open Transport (2019) Tock - The Open Conversation Kit @ CRiP OpenSource Co-d\u00e9veloppement (2017)","title":"Supports de pr\u00e9sentation / meetup"},{"location":"examples/samples/","text":"Exemples de code Tock Les exemples dans Bot Samples Le d\u00e9p\u00f4t github tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket . Le bot Open Data Le d\u00e9p\u00f4t github tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais. TODO : description des principales fonctionnalit\u00e9s, parcours \u00e0 tester, comment tester l'i18n, etc. D\u00e9ployer le bot avec Docker Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker . D\u00e9ployer le bot dans son IDE Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir Les connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :) Tester le bot l'internationalisation TODO","title":"Exemples de code"},{"location":"examples/samples/#exemples-de-code-tock","text":"","title":"Exemples de code Tock"},{"location":"examples/samples/#les-exemples-dans-bot-samples","text":"Le d\u00e9p\u00f4t github tock-bot-samples contient des exemples de code, notamment ceux utilis\u00e9s dans la documentation Tock pour programmer des parcours en modes WebHook ou WebSocket .","title":"Les exemples dans Bot Samples"},{"location":"examples/samples/#le-bot-open-data","text":"Le d\u00e9p\u00f4t github tock-bot-open-data contient un exemple d'impl\u00e9mentation de bot bas\u00e9 sur les API Open Data de la SNCF . Ce bot utilise le framework Kotlin pour Tock (et pas le mode Bot API via Webhook ou WebSocket ). Il impl\u00e9mente \u00e9galement une internationalisation avec deux langues propos\u00e9es : Fran\u00e7ais et Anglais. TODO : description des principales fonctionnalit\u00e9s, parcours \u00e0 tester, comment tester l'i18n, etc.","title":"Le bot Open Data"},{"location":"examples/samples/#deployer-le-bot-avec-docker","text":"Pour d\u00e9ployer le bot avec Docker / Docker Compose , suivez les instructions du d\u00e9p\u00f4t tock-docker .","title":"D\u00e9ployer le bot avec Docker"},{"location":"examples/samples/#deployer-le-bot-dans-son-ide","text":"Si vous pr\u00e9f\u00e9rez d\u00e9ployer une plateforme Tock sans le Bot Open Data, et ex\u00e9cuter celui-ci dans votre IDE (vous permettant par exemple de faire du debug pas-\u00e0-pas), suivez ces instructions : D\u00e9ployez une stack Tock NLU gr\u00e2ce au descripteur docker-compose.yml comme expliqu\u00e9 ici Demandez votre propre clef SNCF Open Data (gratuite) et configurez la variable d'environnement (voir OpenDataConfiguration ) Configurez un connecteur : Messenger, Google Assistant ou autre (voir Les connecteurs ) D\u00e9marrez le lanceur OpenDataBot dans votre IDE, IntelliJ ou autre. Le bot est op\u00e9rationnel, parlez-lui ! :)","title":"D\u00e9ployer le bot dans son IDE"},{"location":"examples/samples/#tester-le-bot-linternationalisation","text":"TODO","title":"Tester le bot &amp; l'internationalisation"},{"location":"examples/users/","text":"Usages utilisateurs Depuis la cr\u00e9ation de la plateforme pour OUI.sncf en 2016, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer business to business distribution, parcours transactionnels, paiement assistance, care , help desk , FAQ etc. Cette page pr\u00e9sente des exemples de bots construits avec Tock. N'h\u00e9sitez pas \u00e0 partager vos propres r\u00e9alisations. OUIbot , le bot OUI.sncf OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes push notifications, relai vers un agent Canaux : texte voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux L'Assistant SNCF L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS Tilien , le chatbot Transilien Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger Mon Assistant TGV INOUI Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI , l'assistant qui s'appuie sur Tock est \u00e9galement accessible depuis le SMS de rappel E-Billet ou directement depuis l'application. Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur Messenger (page Facebook TGV INOUI ) L'Agent virtuel SNCF L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic. Accessible via la page Facebook de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur Messenger (page Facebook SNCF ) Eve , le bot interne e-voyageurs Eve est l'assistant interne des collaborateurs e-voyageurs . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte, en interne dans l'entreprise et en mobilit\u00e9 via Teams","title":"Usages & utilisateurs"},{"location":"examples/users/#usages-utilisateurs","text":"Depuis la cr\u00e9ation de la plateforme pour OUI.sncf en 2016, Tock est utilis\u00e9 par de plus en plus d'\u00e9quipes pour cr\u00e9er des bots conversationnels d\u00e9di\u00e9s \u00e0 des usages divers : business to customer business to business distribution, parcours transactionnels, paiement assistance, care , help desk , FAQ etc. Cette page pr\u00e9sente des exemples de bots construits avec Tock. N'h\u00e9sitez pas \u00e0 partager vos propres r\u00e9alisations.","title":"Usages &amp; utilisateurs"},{"location":"examples/users/#ouibot-le-bot-ouisncf","text":"OUIbot est l'assistant conversationnel de OUI.sncf. Disponible depuis 2016 sur le r\u00e9seau social Facebook Messenger, OUIbot s'est construit avec les premi\u00e8res versions de Tock. Avec OUIbot, r\u00e9server un billet de train n'a jamais \u00e9t\u00e9 aussi simple ! Il vous assiste dans la pr\u00e9paration de vos voyages, permet d'effectuer rapidement et simplement une r\u00e9servation compl\u00e8te, de la recherche \u00e0 l'achat (paiement inclus), et vous accompagne durant votre voyage. Gr\u00e2ce aux nombreux connecteurs Tock, OUIbot r\u00e9pond pr\u00e9sent sur de nombreux canaux conversationnels : site www.oui.sncf , r\u00e9seaux sociaux, assistants vocaux, enceintes connect\u00e9es et m\u00eame IAffiches avec JCDecaux . En 2019, OUIbot accompagne pr\u00e8s de 10 000 utilisateurs par jour. Il a \u00e9t\u00e9 \u00e9lu Best Robot Experience pour la deuxi\u00e8me ann\u00e9e cons\u00e9cutive. Nom : OUIbot Date de naissance : en production depuis 2016 Domaine : distribution, transactionnel (r\u00e9servations, paiements), alertes push notifications, relai vers un agent Canaux : texte voix, sur le site Web entreprise, Messenger, WhatsApp, Business Chat (Messages), Google Assistant, Google Home, Alexa, IAffiches JCDecaux","title":"OUIbot, le bot OUI.sncf"},{"location":"examples/users/#lassistant-sncf","text":"L'Assistant SNCF est l'application mobile des voyageurs SNCF sur Android et iOS, couvrant le train mais aussi d'autres modes de transport. Avec l\u2019 Assistant SNCF , vous pouvez calculer votre itin\u00e9raire, rester inform\u00e9 en temps r\u00e9el, acheter directement vos tickets de transport ou encore r\u00e9server votre course en VTC. En attendant de nouvelles fonctionnalit\u00e9s \u00e0 venir. Accessible via le \"microphone\" dans l'application mobile, le bot conversationnel de l' Assistant SNCF est construit avec Tock et les fonctions speech-to-text Android et iOS. Nom : L'Assistant SNCF Date de naissance : en production, fonction vocale Tock depuis 2019 Domaine : voyage transport (recherche itin\u00e9raires en multi-modal, etc.) Canaux : vocal, sur l'application mobile SNCF pour Android et iOS","title":"L'Assistant SNCF"},{"location":"examples/users/#tilien-le-chatbot-transilien","text":"Tilien est le chatbot Transilien sur Messenger. Con\u00e7u comme un compagnon de voyage personnel et amical, il informe des prochains d\u00e9parts, l'\u00e9tat du trafic, les travaux en cours et \u00e0 venir, propose des itin\u00e9raires et bien d'autres choses (plans des lignes, fiches horaires, etc.) sur l'ensemble du r\u00e9seau ferr\u00e9 Ile-De-France : M\u00e9tro, RER, Transilien, Tram. Motoris\u00e9 par Tock, le chatbot vous attend sur Facebook Messenger pour offrir ses services. Nom : Tilien Date de naissance : en production, depuis 2018 sur Tock Domaine : transport assistance (recherche itin\u00e9raires, plans des lignes, \u00e9tat du trafic, etc.) Canaux : texte, sur Messenger","title":"Tilien, le chatbot Transilien"},{"location":"examples/users/#mon-assistant-tgv-inoui","text":"Mon Assistant informe les clients et voyageurs de la marque TGV INOUI avant, pendant et apr\u00e8s leur trajet. Le chatbot est capable de donner l'\u00e9tat du trafic, le quai de d\u00e9part d'un train, la ou les places du client, les services \u00e0 bord (le bar, les prises \u00e9lectriques, etc.). Il permet aussi de parler avec un agent SNCF tout en restant dans la m\u00eame conversation. Pr\u00e9sent sur la page Facebook TGV INOUI , l'assistant qui s'appuie sur Tock est \u00e9galement accessible depuis le SMS de rappel E-Billet ou directement depuis l'application. Nom : Mon Assistant TGV INOUI Date de naissance : en production depuis 2019 Domaine : assistance info voyageur (info quai, infos voyage en cours, services \u00e0 bord), relai vers un agent Canaux : texte, sur Messenger (page Facebook TGV INOUI )","title":"Mon Assistant TGV INOUI"},{"location":"examples/users/#lagent-virtuel-sncf","text":"L' Agent virtuel SNCF pr\u00e9sente de mani\u00e8re conversationnelle l'information voyageur et les \u00e9ventuelles perturbations sur tous les trains (TGV, IC, TER, Eurostar...). On peut interroger le bot par num\u00e9ro de train, dossier voyageur, prochains d\u00e9parts, etc. pour obtenir les derni\u00e8res informations et l'\u00e9tat du trafic. Accessible via la page Facebook de la SNCF, l' Agent virtuel est bas\u00e9 sur Tock. Nom : Agent virtuel SNCF Date de naissance : en production depuis 2019 Domaine : voyage transport (\u00e9tat du trafic, travaux, prochains d\u00e9parts), relai vers un agent Canaux : texte, sur Messenger (page Facebook SNCF )","title":"L'Agent virtuel SNCF"},{"location":"examples/users/#eve-le-bot-interne-e-voyageurs","text":"Eve est l'assistant interne des collaborateurs e-voyageurs . Le chatbot r\u00e9pond aux questions courantes, renvoie vers les bons contacts et outils collaboratifs de l'entreprise, automatise des demandes courantes au Support Informatique, Services G\u00e9n\u00e9raux, Direction Juridique, etc. Les \u00e9quipes Devops peuvent aussi lui demander l'\u00e9tat de la production, les prochaines interventions, voire d'effectuer directement certaines op\u00e9rations pour plus de simplicit\u00e9 et de r\u00e9activit\u00e9. Eve est \u00e0 l'\u00e9coute des collaborateurs dans l'entreprise et en mobilit\u00e9 sur Teams avec Tock. Nom : Eve Date de naissance : en production depuis 2019 Domaine : assistance en interne B2B (FAQ, Support Informatique, RH, Juridique), automatisations DevOps (supervision, d\u00e9ploiements, gestion de production, etc.) Canaux : texte, en interne dans l'entreprise et en mobilit\u00e9 via Teams","title":"Eve, le bot interne e-voyageurs"},{"location":"getting-started/start-api/","text":"Programmer des parcours en Kotlin Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio . Ce que vous allez cr\u00e9er Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s Pr\u00e9-requis Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock . Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId test /groupId artifactId tock-kotlin-websocket /artifactId version 0.0.1-SNAPSHOT /version properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.build.sourceDirectory ${project.basedir}/src/main/kotlin /project.build.sourceDirectory project.build.testSourceDirectory ${project.basedir}/src/test/kotlin /project.build.testSourceDirectory lib.tock.version 19.3.2 /lib.tock.version plugin.kotlin.version 1.3.41 /plugin.kotlin.version plugin.source.version 3.1.0 /plugin.source.version /properties dependencies dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-websocket /artifactId version ${lib.tock.version} /version /dependency /dependencies build sourceDirectory ${project.build.sourceDirectory} /sourceDirectory testSourceDirectory ${project.build.testSourceDirectory} /testSourceDirectory plugins plugin groupId org.jetbrains.kotlin /groupId artifactId kotlin-maven-plugin /artifactId version ${plugin.kotlin.version} /version executions execution id compile /id phase compile /phase goals goal compile /goal /goals /execution execution id test-compile /id phase test-compile /phase goals goal test-compile /goal /goals /execution /executions /plugin plugin groupId org.apache.maven.plugins /groupId artifactId maven-source-plugin /artifactId version ${plugin.source.version} /version executions execution id attach-sources /id phase verify /phase goals goal jar-no-fork /goal /goals /execution /executions /plugin /plugins /build /project Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Cr\u00e9er une fonction qui se connecte \u00e0 Tock Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import fr.vsct.tock.bot.api.client.newBot import fr.vsct.tock.bot.api.client.newStory import fr.vsct.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( qui-es-tu ) { // Answer for the qui-es-tu story send ( Je suis un assistant conversationnel construit avec Tock ) end ( Comment puis-je aider ? ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [ main ] INFO fr . vsct . tock . bot . api . websocket . BotApiWebSocketClient - start web socket client : { ... } V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API. Terminer la configuration dans Tock Studio Retournez dans Tock et allez dans Build Search Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test Test the bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans NLU Intents build (la cat\u00e9gorie par d\u00e9faut). TODO : fix #533 Allez dans NLU Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test Test the bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\"). F\u00e9licitations! Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution. Continuer... Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Programmer des parcours"},{"location":"getting-started/start-api/#programmer-des-parcours-en-kotlin","text":"Les interfaces Tock Studio permettent de cr\u00e9er des bots et des parcours relativement simples, comme des arbres de d\u00e9cision et des r\u00e9ponses \u00e0 des questions courantes. Cela s'av\u00e8re suffisant pour de nombreux cas d'usages conversationnels. Toutefois, il est possible de construire des r\u00e9ponses et des parcours plus complexes : Se brancher \u00e0 un compte utilisateur Aggr\u00e9ger les informations de r\u00e9f\u00e9rentiels m\u00e9tier Appeler les services du SI (Syst\u00e8me d'Information) dans une organisation Int\u00e9grer des API externes pour enrichir ses parcours de services tiers Effectuer des actions et des transactions : cr\u00e9ation de tickets, paiements, etc. Impl\u00e9menter des r\u00e8gles de gestion et comportements sp\u00e9cifiques Optimiser les encha\u00eenements entre les intentions Pour construire des parcours complexes, Tock propose plusieurs modes d'int\u00e9gration destin\u00e9s \u00e0 diff\u00e9rents langages et frameworks de d\u00e9veloppement. Dans ce guide, vous utiliserez le langage Kotlin et le mode WebSocket pour ajouter une intention \u00e0 un bot initi\u00e9 dans Tock Studio . Si vous le souhaitez, vous pouvez sauter cette \u00e9tape et d\u00e9ployer un plateforme avec Docker ou passer directement au manuel utilisateur pour en savoir plus sur les possibilit\u00e9s de Tock Studio .","title":"Programmer des parcours en Kotlin"},{"location":"getting-started/start-api/#ce-que-vous-allez-creer","text":"Une intention Tock d\u00e9velopp\u00e9e avec le langage Kotlin Un programme se connectant au bot en WebSocket pour l'enrichir de parcours programm\u00e9s","title":"Ce que vous allez cr\u00e9er"},{"location":"getting-started/start-api/#pre-requis","text":"Environ 10 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Si vous ne souhaitez pas utiliser d' IDE , ou Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de r\u00e9aliser le m\u00eame exercice avec d'autres outils. Il est \u00e9galement possible d'utiliser d'autres mani\u00e8res de d\u00e9velopper que le mode WebSocket et d'autres langages que Kotlin. Vous en apprendrez plus dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"getting-started/start-api/#creer-un-programme-kotlin-avec-la-dependance-tock","text":"Il existe de nombreuses mani\u00e8res de cr\u00e9er un projet en Kotlin. Ajoutez au classpath la biblioth\u00e8que tock-bot-api-websocket pour le mode WebSocket . Si vous utilisez Apache Maven , voici un exemple de POM ( pom.xml ) pour Kotlin avec la d\u00e9pendance tock-bot-api-websocket incluse : ?xml version= 1.0 encoding= UTF-8 ? project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd modelVersion 4.0.0 /modelVersion groupId test /groupId artifactId tock-kotlin-websocket /artifactId version 0.0.1-SNAPSHOT /version properties project.build.sourceEncoding UTF-8 /project.build.sourceEncoding project.build.sourceDirectory ${project.basedir}/src/main/kotlin /project.build.sourceDirectory project.build.testSourceDirectory ${project.basedir}/src/test/kotlin /project.build.testSourceDirectory lib.tock.version 19.3.2 /lib.tock.version plugin.kotlin.version 1.3.41 /plugin.kotlin.version plugin.source.version 3.1.0 /plugin.source.version /properties dependencies dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-websocket /artifactId version ${lib.tock.version} /version /dependency /dependencies build sourceDirectory ${project.build.sourceDirectory} /sourceDirectory testSourceDirectory ${project.build.testSourceDirectory} /testSourceDirectory plugins plugin groupId org.jetbrains.kotlin /groupId artifactId kotlin-maven-plugin /artifactId version ${plugin.kotlin.version} /version executions execution id compile /id phase compile /phase goals goal compile /goal /goals /execution execution id test-compile /id phase test-compile /phase goals goal test-compile /goal /goals /execution /executions /plugin plugin groupId org.apache.maven.plugins /groupId artifactId maven-source-plugin /artifactId version ${plugin.source.version} /version executions execution id attach-sources /id phase verify /phase goals goal jar-no-fork /goal /goals /execution /executions /plugin /plugins /build /project Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples .","title":"Cr\u00e9er un programme Kotlin avec la d\u00e9pendance Tock"},{"location":"getting-started/start-api/#creer-une-fonction-qui-se-connecte-a-tock","text":"Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import fr.vsct.tock.bot.api.client.newBot import fr.vsct.tock.bot.api.client.newStory import fr.vsct.tock.bot.api.websocket.startWithDemo fun main () { startWithDemo ( // Integrate with the Tock demo platform by default newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( qui-es-tu ) { // Answer for the qui-es-tu story send ( Je suis un assistant conversationnel construit avec Tock ) end ( Comment puis-je aider ? ) } ) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Vous devriez voir appara\u00eetre une ligne de log ressemblant \u00e0 celle-ci : [ main ] INFO fr . vsct . tock . bot . api . websocket . BotApiWebSocketClient - start web socket client : { ... } V\u00e9rifiez \u00e9ventuellement que d'autres logs provenant de BotApiWebSocketClient n'indiquent pas d'erreur. Si c'est le cas, il peut s'agir d'une erreur de configuration de la clef d'API.","title":"Cr\u00e9er une fonction qui se connecte \u00e0 Tock"},{"location":"getting-started/start-api/#terminer-la-configuration-dans-tock-studio","text":"Retournez dans Tock et allez dans Build Search Stories D\u00e9cochez l'option Only Configured Stories . Vous voyez alors tous parcours, y compris \"qui-es-tu\" que vous venez de d\u00e9clarer programmatiquement Allez dans Test Test the bot et saisissez une ou plusieurs phrases comme \"qui es-tu ?\" par exemple. Vous contastez que le bot ne r\u00e9pond pas encore \u00e0 cette question - il r\u00e9pond peut-\u00eatre m\u00eame \u00e0 une autre intention. Il reste en effet une configuration \u00e0 effectuer pour que la qualification fonctionne. A ce stade, le parcours existe bien dans Tock, mais l' intention n'a pas \u00e9t\u00e9 cr\u00e9\u00e9e automatiquement. Vous pouvez le v\u00e9rifier en regardant la liste des intentions disponibles dans NLU Intents build (la cat\u00e9gorie par d\u00e9faut). TODO : fix #533 Allez dans NLU Inbox , pour la derni\u00e8re phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Puis terminez la qualification de la phrase avec Validate Si vous avez saisi d'autres phrases pour cette intention, pour chacune d'elles s\u00e9lectionnez l'intention dans la liste puis confirmez avec Validate Retournez dans Test Test the bot . Si vous reposez la question, le bot vous donne d\u00e9sormais la r\u00e9ponse construite dans le code Kotlin (ie. \"Je suis un assistant...\").","title":"Terminer la configuration dans Tock Studio"},{"location":"getting-started/start-api/#felicitations","text":"Vous venez de configurer votre premi\u00e8re story programmatique en Kotlin. De cette mani\u00e8re, vous pouvez tirer pleinement parti des possibilit\u00e9s d'un langage de programmation pour construire toutes sortes de parcours simples et complexes, interroger des API tierces, impl\u00e9menter des r\u00e8gles de gestion, etc. Si vous programmez ainsi une story d\u00e9j\u00e0 d\u00e9finie dans Tock Studio , c'est la d\u00e9finition pr\u00e9sente dans Tock Studio qui est utilis\u00e9e pour construire les r\u00e9ponses \u00e0 l'ex\u00e9cution.","title":"F\u00e9licitations!"},{"location":"getting-started/start-api/#continuer","text":"Dans la section suivante vous apprendez \u00e0 : D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur l'utilisation de Tock Bot API en mode WebSocket , mais aussi les autres modes de d\u00e9ploiement, les types de messages support\u00e9s par Tock, etc. vous pouvez consulter le manuel utilisateur .","title":"Continuer..."},{"location":"getting-started/start-messenger/","text":"Configurer son bot pour Messenger TODO","title":"Configurer Messenger"},{"location":"getting-started/start-messenger/#configurer-son-bot-pour-messenger","text":"TODO","title":"Configurer son bot pour Messenger"},{"location":"getting-started/start-platform/","text":"D\u00e9ployer une plateforme avec Docker Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production. Ce que vous allez cr\u00e9er Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket Pr\u00e9-requis Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock . D\u00e9ployer une plateforme Tock - sans les sources Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t github, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from github (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from github $ mkdir -p scripts curl -o scripts/setup.sh https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/scripts/setup.sh chmod +x scripts/setup.sh # Get the lastest Tock version/tag from github $ curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env # Run the stack $ docker-compose up D\u00e9ployer une plateforme Tock - depuis les sources Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de github en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from github $ git clone https://github.com/voyages-sncf-technologies/tock-docker.git cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up Acc\u00e9der \u00e0 Tock Studio Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.). Cr\u00e9er une application, un connecteur et une intention Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Configuration Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Build New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Connecter un parcours en Kotlin (optionnel) Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import fr.vsct.tock.bot.api.client.newBot import fr.vsct.tock.bot.api.client.newStory import fr.vsct.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( qui-es-tu ) { // Answer for the qui-es-tu story send ( Je suis un assistant conversationnel construit avec Tock ) end ( Comment puis-je aider ? ) } ), http://localhost:8080 // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test Test the bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans NLU Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test Test the bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond ! F\u00e9licitations! Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section installation du manuel Tock. Continuer... Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"D\u00e9ployer avec Docker"},{"location":"getting-started/start-platform/#deployer-une-plateforme-avec-docker","text":"Dans les sections pr\u00e9c\u00e9dentes pour d\u00e9couvrir et tester Tock, vous avez utilis\u00e9 la plateforme de d\u00e9monstration . Cela vous a permis de d\u00e9couvrir la construction et la configuration des bots Tock sans avoir \u00e0 installer la plateforme au pr\u00e9alable. Dans ce guide, vous allez apprendre \u00e0 d\u00e9ployer une plateforme compl\u00e8te Tock en quelques minutes, gr\u00e2ce aux exemples d'impl\u00e9mentations Docker / Docker Compose fournies. Notez qu'il est tout \u00e0 fait possible de d\u00e9ployer Tock sans utiliser Docker. Une section sp\u00e9cifique du manuel utilisateur vous en apprendra plus sur l'architecture, les possibilit\u00e9s et les recommandations pour le d\u00e9ploiement et l'utilisation de Tock en production.","title":"D\u00e9ployer une plateforme avec Docker"},{"location":"getting-started/start-platform/#ce-que-vous-allez-creer","text":"Une plateforme Tock compl\u00e8te en local : Tock Studio , Bot API , etc. Un bot et une configuration minimale pour tester la plateforme (Optionnel) Un programme Kotlin se connectant \u00e0 la plateforme locale en WebSocket","title":"Ce que vous allez cr\u00e9er"},{"location":"getting-started/start-platform/#pre-requis","text":"Environ 20 minutes Pour d\u00e9ployer la plateforme en local, un environnement de d\u00e9veloppement avec des versions r\u00e9centes de Docker et Docker Compose install\u00e9es Si vous ne souhaitez pas utiliser Docker, pas de probl\u00e8me. Il y a d'autres mani\u00e8res de d\u00e9ployer la base MongoDB et les services Kotlin sur JVM. Vous pouvez toutefois parcourir les Dockerfile et docker-compose.yml \u00e0 titre d'exemples pour instancier ces services. (Optionnel) Pour le programme en WebSocket, un environnement de d\u00e9veloppement (ou IDE ) supportant Kotlin , par exemple IntelliJ avec des versions r\u00e9centes du JDK et de Maven Sans IDE ou sans Maven, pas de probl\u00e8me. Il est tout \u00e0 fait possible de compiler et ex\u00e9cuter le programme avec d'autres outils. D'autres modes que Kotlin et WebSocket sont pr\u00e9sent\u00e9s dans le manuel utilisateur Tock .","title":"Pr\u00e9-requis"},{"location":"getting-started/start-platform/#deployer-une-plateforme-tock-sans-les-sources","text":"Il est possible de r\u00e9cup\u00e9rer seulement quelques fichiers du d\u00e9p\u00f4t github, sans t\u00e9l\u00e9charger toutes les sources Tock. En quelques lignes de commande, la plateforme est op\u00e9rationnelle. Il est cependant indispensable d'avoir des versions r\u00e9centes de Docker et Docker Compose . Pour d\u00e9marrer depuis les sources du d\u00e9p\u00f4t Tock Docker, passez plut\u00f4t au paragraphe suivant . # Get the lastest docker-compose from github (including Bot API) $ curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose-bot.yml # Get the lastest database-init script from github $ mkdir -p scripts curl -o scripts/setup.sh https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/scripts/setup.sh chmod +x scripts/setup.sh # Get the lastest Tock version/tag from github $ curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env # Run the stack $ docker-compose up","title":"D\u00e9ployer une plateforme Tock - sans les sources"},{"location":"getting-started/start-platform/#deployer-une-plateforme-tock-depuis-les-sources","text":"Ceci est une mani\u00e8re alternative de d\u00e9marrer Tock, \u00e0 partir du d\u00e9p\u00f4t Tock Docker . Il vous faut, en plus de Docker et Docker Compose , soit un client Git pour r\u00e9cup\u00e9rer les sources (commande git clone ) soit avoir d\u00e9j\u00e0 copi\u00e9 les sources de github en local. Pour d\u00e9marrer sans Git ni les sources du d\u00e9p\u00f4t en local, suivez le paragraphe pr\u00e9c\u00e9dent . # Get the lastest sources from github $ git clone https://github.com/voyages-sncf-technologies/tock-docker.git cd tock-docker # Make the database-init script executable $ chmod +x scripts/setup.sh # Run the stack (including Bot API) $ docker-compose -f docker-compose-bot.yml up","title":"D\u00e9ployer une plateforme Tock - depuis les sources"},{"location":"getting-started/start-platform/#acceder-a-tock-studio","text":"Une fois la plateforme pr\u00eate, les interfaces Tock Studio sont sur le port 80 par d\u00e9faut : Allez sur http://localhost Apr\u00e8s le d\u00e9ploiement de la plateforme, celle-ci s'initialise, et il peut falloir attendre quelques secondes avant que les interfaces Tock Studio soient accessibles. Connectez-vous avec les identifiants admin@app.com / password par d\u00e9faut Il est \u00e9videmment recommand\u00e9 de changer ces valeurs \u00e0 l'installation d'une plateforme destin\u00e9e \u00e0 une utilisation p\u00e9renne (production, plateforme partag\u00e9e entre \u00e9quipes, etc.).","title":"Acc\u00e9der \u00e0 Tock Studio"},{"location":"getting-started/start-platform/#creer-une-application-un-connecteur-et-une-intention","text":"Comme dans le guide premier bot utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Tock et un connecteur pour commencer \u00e0 utiliser la plateforme locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de commentaires. Au premier acc\u00e8s \u00e0 la plateforme locale : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Allez dans Configuration Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez l' API Key automatiquement g\u00e9n\u00e9r\u00e9e pour votre application. Elle vous servira si vous essayez le mode WebSocket dans la suite de ce guide (optionnel). Allez dans Build New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Allez dans Test Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16","title":"Cr\u00e9er une application, un connecteur et une intention"},{"location":"getting-started/start-platform/#connecter-un-parcours-en-kotlin-optionnel","text":"Comme dans le guide programmer des parcours utilisant la plateforme de d\u00e9monstration, vous allez cr\u00e9er une application Kotlin se connectant en WebSocket \u00e0 la plateforme Tock locale. N'h\u00e9sitez pas \u00e0 retourner voir les pr\u00e9c\u00e9dents guides pour plus de d\u00e9tails. Cr\u00e9ez un projet Kotlin par exemple avec Maven comme indiqu\u00e9 dans le guide programmer des parcours Le classpath doit inclure tock-bot-api-websocket pour utiliser le mode WebSocket . Cr\u00e9ez un fichier Kotlin (par exemple dans `src/main/kotlin/StartWebSocket.kt) Editez-le avec le code suivant : import fr.vsct.tock.bot.api.client.newBot import fr.vsct.tock.bot.api.client.newStory import fr.vsct.tock.bot.api.websocket.start fun main () { start ( // Do not use #startWithDemo when integrating with a local platform newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( qui-es-tu ) { // Answer for the qui-es-tu story send ( Je suis un assistant conversationnel construit avec Tock ) end ( Comment puis-je aider ? ) } ), http://localhost:8080 // Local platform URL (default host/port) ) } Vous pouvez retrouver ce code (et d'autres exemples) dans le d\u00e9p\u00f4t tock-bot-samples . Remplacez la clef d'API par celle de votre propre application Tock. Pour cela, dans Tock Studio , allez dans Configuration Bot Configurations et reportez la valeur API Key dans le code. Ex\u00e9cutez la fonction ( main ) dans votre environnement de d\u00e9veloppement. Retournez dans Tock dans Test Test the bot et dites \"qui es-tu ?\" : le bot ne r\u00e9pond pas encore. Allez dans NLU Inbox , pour la phrase que vous venez de saisir : Changez l'intention pour New intent Nommez-la \"qui-es-tu\" comme dans le code (pour que le lien se fasse) Cr\u00e9ez l'intention avec Create Terminez la qualification de la phrase avec Validate Retournez dans Test Test the bot . Dites \"qui es-tu ?\" : le bot r\u00e9pond !","title":"Connecter un parcours en Kotlin (optionnel)"},{"location":"getting-started/start-platform/#felicitations","text":"Vous venez de d\u00e9ployer votre propre plateforme conversationnelle Tock en local. Cela peut servir \u00e0 mieux appr\u00e9hender l'architecture et v\u00e9rifier la portabilit\u00e9 de la solution, mais aussi lors de d\u00e9veloppements, pour les contributeurs Tock ou encore si vous devez travailler sans acc\u00e8s \u00e0 Internet (en mobilit\u00e9, sur un r\u00e9seau restreint, etc.). Attention, l'impl\u00e9mentation Docker fournie ne suffit pas \u00e0 garantir r\u00e9silience et mont\u00e9e en charge de la plateforme quelles que soient les conditions en production. Pour cela, quelques recommandations sont propos\u00e9es dans la section installation du manuel Tock.","title":"F\u00e9licitations!"},{"location":"getting-started/start-platform/#continuer","text":"Vous venez de terminer les guides de d\u00e9marrage rapide Tock. A partir de l\u00e0, vous pouvez vous lancer directement sur une plateforme Tock, ou parcourir le manuel utilisateur pour en savoir plus sur Tock Studio , Bot API et Bot Flow par exemple. D'autres pages pr\u00e9sentent aussi des \u00e9tudes de cas clients, des exemples de code, comment contacter la communaut\u00e9 Tock, etc.","title":"Continuer..."},{"location":"getting-started/start-slack/","text":"Configurer son bot pour Slack Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite . Ce que vous allez cr\u00e9er Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack Pr\u00e9-requis Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/ Cr\u00e9er une application dans Slack Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App Activer l'envoi de messages \u00e0 Slack Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update Activer la reception de messages depuis Slack Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demotock-production-admin.vsct-prod.aws.vsct.fr/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes Cr\u00e9er un bot Slack (et lui parler) Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et parlez au bot (par exemple \"bonjour\"). Le bot vous r\u00e9pond maintenant dans Slack ! Regarder la conversation dans Tock Studio (optionnel) Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : NLU Inbox et Logs , Build Bot Flow ou encore Monitoring Users et Dialogs : Dans Tock, ouvrez Monitoring Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack F\u00e9licitations! Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir. Continuer... Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur github, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Configurer Slack"},{"location":"getting-started/start-slack/#configurer-son-bot-pour-slack","text":"Si vous avez suivi le guide Cr\u00e9er son premier bot avec Tock Studio , vous avez d\u00e9clar\u00e9 un connecteur de type Slack mais celui-ci n'est pas encore configur\u00e9 pour que le bot parle r\u00e9ellement sur Slack . Avec un peu de configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock, un bot peut recevoir des messages et r\u00e9pondre sur ce canal. Si vous le souhaitez, vous pouvez aussi sauter cette \u00e9tape et configurer un canal Messenger ou passer directement \u00e0 la suite .","title":"Configurer son bot pour Slack"},{"location":"getting-started/start-slack/#ce-que-vous-allez-creer","text":"Une configuration (dans Slack et dans Tock) pour recevoir et envoyer des messages Slack Un bot qui parle sur une cha\u00eene Slack","title":"Ce que vous allez cr\u00e9er"},{"location":"getting-started/start-slack/#pre-requis","text":"Environ 15 minutes Un bot Tock fonctionnel (par exemple suite au guide premier bot Tock ) Un compte Slack et un espace de travail / une cha\u00eene o\u00f9 int\u00e9grer le bot Si vous n'avez jamais utilis\u00e9 Slack, rendez-vous sur sur https://slack.com/","title":"Pr\u00e9-requis"},{"location":"getting-started/start-slack/#creer-une-application-dans-slack","text":"Allez sur la page Create a Slack app Entrez un nom pour l' application S\u00e9lectionnez un espace de travail Terminez avec Create App","title":"Cr\u00e9er une application dans Slack"},{"location":"getting-started/start-slack/#activer-lenvoi-de-messages-a-slack","text":"Ouvrez Incoming Webhooks et cochez Activate Incoming Webhooks Cliquez sur Add New Webhook to Workspace S\u00e9lectionnez une cha\u00eene ou une personne pour la conversation avec le bot Terminez par Installer Copiez la Webhook URL qui vient d'\u00eatre cr\u00e9\u00e9e La Webhook URL ressemble dans son format \u00e0 quelque chose comme : https://hooks.slack.com/services/{workspaceToken}/{webhookToken}/{authToken} Dans Tock Studio allez dans Configuration Bot Configurations Trouvez votre connecteur de type Slack (ou cr\u00e9ez-en un nouveau si besoin) et ouvrez la section Connector Custom Configuration Saisissez dans les trois champs tokens les jetons issus de l'adresse pr\u00e9c\u00e9demment copi\u00e9e : Token 1 : le premier token de la WebhookURL , ou workspaceToken Token 2 : le deuxi\u00e8me token de la WebhookURL , ou webhookToken Token 3 : le dernier token de la WebhookURL , ou authToken Terminez avec Update","title":"Activer l'envoi de messages \u00e0 Slack"},{"location":"getting-started/start-slack/#activer-la-reception-de-messages-depuis-slack","text":"Dans la page de votre application Slack, allez dans Event Subscriptions et activez Enable Events Entrez dans le champ Request URL l'adresse compl\u00e8te de votre connecteur Slack dans Tock. Sur la plateforme de d\u00e9monstration Tock, cette adresse sera du type https://demotock-production-admin.vsct-prod.aws.vsct.fr/{chemin_relatif_du_connecteur_slack} Le chemin relatif du connecteur est indiqu\u00e9 dans la page Bot Configurations . Sur la ligne correspondant \u00e0 votre connecteur Slack, il s'agit du champ Relative REST path Ouvrez Add Workspace Event et s\u00e9lectionnez l'\u00e9venement message.channels Validez avec Save Changes Allez dans Interactive Components et activez Interactivity Entrez la m\u00eame Request URL que pr\u00e9c\u00e9demment Validez avec Save Changes","title":"Activer la reception de messages depuis Slack"},{"location":"getting-started/start-slack/#creer-un-bot-slack-et-lui-parler","text":"Dans la page de votre application Slack, allez dans Bot Users et faites Add a Bot User Choisissez un nom / identifiant pour le bot dans Slack Validez avec Add Bot User Allez dans Install App et Reinstall App S\u00e9lectionnez la cha\u00eene Slack puis Installer Dans Slack, allez sur la cha\u00eene et parlez au bot (par exemple \"bonjour\"). Le bot vous r\u00e9pond maintenant dans Slack !","title":"Cr\u00e9er un bot Slack (et lui parler)"},{"location":"getting-started/start-slack/#regarder-la-conversation-dans-tock-studio-optionnel","text":"Quelque soient les canaux utilis\u00e9s pour converser avec le bot, vous pouvez suivre les conversations directement dans tous les \u00e9crans Tock Studio , par exemple : NLU Inbox et Logs , Build Bot Flow ou encore Monitoring Users et Dialogs : Dans Tock, ouvrez Monitoring Users et cliquez sur l'ic\u00f4ne Display dialog pour voir toute la conversation provenant de Slack","title":"Regarder la conversation dans Tock Studio (optionnel)"},{"location":"getting-started/start-slack/#felicitations","text":"Vous venez de configurer votre bot pour qu'il parle \u00e9galement sur Slack. Comme vous le constatez, connecter un bot Tock \u00e0 un (ou plusieurs) canaux externes n'est qu'une affaire de configuration. Vous pouvez construire le mod\u00e8le conversationnel, les fonctionnalit\u00e9s et la personnalit\u00e9 de votre assistant ind\u00e9pendamment des canaux sur lesquels vous souhaitez lui parler, aujourd'hui ou \u00e0 l'avenir.","title":"F\u00e9licitations!"},{"location":"getting-started/start-slack/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur le connecteur Slack fourni avec Tock, rendez-vous dans le dossier connector-slack sur github, o\u00f9 vous retrouverez les sources et le README du connecteur. Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"getting-started/start-studio/","text":"Cr\u00e9er son premier bot avec Tock Studio Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code. Ce que vous allez cr\u00e9er Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42 Pr\u00e9-requis Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte github pour se connecter \u00e0 la plateforme de d\u00e9monstration Connexion \u00e0 la plateforme d\u00e9mo Ouvrez ce lien pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte github. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte github sera lu. Cr\u00e9er une application Tock Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Configuration NLU Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application . Ajouter un connecteur Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Configuration Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack. Cr\u00e9er un parcours Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu NLU de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Build New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus. Tester le bot Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne lanque (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur. Am\u00e9liorer la compr\u00e9hension En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie NLU de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans NLU Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test Test the bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement! Cr\u00e9er d'autres parcours (optionnel) Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs. F\u00e9licitations! Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code. Continuer... Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Cr\u00e9er son premier bot"},{"location":"getting-started/start-studio/#creer-son-premier-bot-avec-tock-studio","text":"Un bon moyen de tester Tock est certainement de cr\u00e9er son premier bot conversationnel dans Tock Studio (l'interface graphiques fournie avec la plateforme). En se connectant \u00e0 la plateforme de d\u00e9monstration Tock, il est possible de cr\u00e9er et tester un assistant en quelques minutes sans \u00e9crire de code.","title":"Cr\u00e9er son premier bot avec Tock Studio"},{"location":"getting-started/start-studio/#ce-que-vous-allez-creer","text":"Une application et un connecteur sur la plateforme de d\u00e9monstration Tock Une story : phrase utilisateur / r\u00e9ponse du bot, testable dans l'interface Tock Studio Un assistant qui r\u00e9pond quand vous lui dites \"bonjour\" ! \ud83d\ude42","title":"Ce que vous allez cr\u00e9er"},{"location":"getting-started/start-studio/#pre-requis","text":"Entre 5 et 15 minutes environ (en lisant les commentaires) Un compte github pour se connecter \u00e0 la plateforme de d\u00e9monstration","title":"Pr\u00e9-requis"},{"location":"getting-started/start-studio/#connexion-a-la-plateforme-demo","text":"Ouvrez ce lien pour acc\u00e9der \u00e0 la plateforme de d\u00e9monstration Tock. Remarque importante : Cette plateforme n'a pas vocation \u00e0 accueillir de v\u00e9ritables bots en production. C'est un moyen de tester et prendre en main la solution Tock sans avoir \u00e0 l'installer. Une invite appara\u00eet pour vous identifier avec votre compte github. Apr\u00e8s cela, vous devez accepter que Tock acc\u00e8de \u00e0 votre compte - seul l'identifiant de votre compte github sera lu.","title":"Connexion \u00e0 la plateforme d\u00e9mo"},{"location":"getting-started/start-studio/#creer-une-application-tock","text":"Au premier acc\u00e8s \u00e0 la plateforme de d\u00e9monstration, un assistant invite \u00e0 cr\u00e9er une application : Saisissez un nom pour l'application S\u00e9lectionnez une langue - vous pourrez en ajouter d'autres par la suite Validez pour cr\u00e9er l'application Vous pouvez retrouver l'application cr\u00e9\u00e9e dans le menu : Configuration NLU Applications . Si vous aviez d\u00e9j\u00e0 cr\u00e9\u00e9 une ou plusieurs applications, vous pouvez en cr\u00e9er de nouvelles en revenant \u00e0 cet \u00e9cran puis Create New Application .","title":"Cr\u00e9er une application Tock"},{"location":"getting-started/start-studio/#ajouter-un-connecteur","text":"Pour int\u00e9ragir avec le bot, il faut utiliser un connecteur afin de l'exposer \u00e0 un canal de communication. De nombreux connecteurs existent pour Tock : Messenger , WhatsApp , Google Assistant et Google Home , Twitter , Alexa , Business Chat , Teams , Slack , Rocket.Chat ... Il est m\u00eame possible de d\u00e9velopper ses propres connecteurs pour ouvrir le bot \u00e0 de nouveaux canaux. Pour ce tutoriel, vous allez configurer un connecteur pour Slack . Dans un premier temps, vous testerez le bot en restant dans l'interface Tock Studio , et n'aurez pas besoin d'utiliser Slack. Dans la section suivante Configurer Slack , vous pourrez compl\u00e9ter la configuration c\u00f4t\u00e9 Slack et c\u00f4t\u00e9 Tock afin que le bot soit fonctionnel sur cette plateforme collaborative. De m\u00eame, la section Configurer Messenger vous montrera comment activer le m\u00eame bot sur la messagerie du r\u00e9seau social Facebook. Cr\u00e9ez un premier connecteur pour votre application : Allez dans Configuration Bot Configurations Create a new Configuration S\u00e9lectionnez le type de connecteur Slack Create Notez qu'une API Key a \u00e9t\u00e9 automatiquement g\u00e9n\u00e9r\u00e9e pour votre application \u00e0 la cr\u00e9ation du premier connecteur. Celle-ci vous servira \u00e0 vous connecter \u00e0 l'API du bot si vous essayez le mode WebHook ou WebSocket dans le guide Programmer des parcours . Si vous cliquez sur Display test configurations , vous pouvez voir qu'une seconde configuration est cr\u00e9\u00e9e. Ce connecteur sp\u00e9cial sera utilis\u00e9 pour tester le bot directement depuis l'interface Tock Studio . Gr\u00e2ce \u00e0 lui, vous pourrez parler au bot sans passer par Slack.","title":"Ajouter un connecteur"},{"location":"getting-started/start-studio/#creer-un-parcours","text":"Un bot conversationnel analyse les phrases des utilisateurs en langage naturel, pour en d\u00e9terminer l' intention et \u00e9ventuellement des entit\u00e9s . Exemple : dans la phrase \"Quel temps fera-t-il demain ?\", le moteur NLU (Natural Language Understanding) de Tock va reconna\u00eetre une intention \"m\u00e9t\u00e9o\" et une entit\u00e9 \"demain\" venant pr\u00e9ciser/param\u00e9trer cette intention. Encore faut-il avoir d\u00e9clar\u00e9 les intentions et entit\u00e9s possibles, puis qualifi\u00e9 des phrases pour apprendre au bot \u00e0 les d\u00e9tecter. Le menu NLU de Tock permet de g\u00e9rer intentions et entit\u00e9s, qualifier les phrases et ainsi superviser l'apprentissage du bot : plus on qualifie de phrases, plus le bot devient pertinent dans sa compr\u00e9hension du langage. Mais laissons intentions et entit\u00e9s de c\u00f4t\u00e9 pour le moment... Le mode Stories de Tock permet en quelques clics de cr\u00e9er automatiquement des intentions ainsi que les r\u00e9ponses \u00e0 fournir. Ainsi, sans quitter l'interface Tock Studio , vous allez cr\u00e9er un premier parcours de question(s)-r\u00e9ponse(s). Allez dans Build New Story Saisissez une phrase utilisateur par exemple \"bonjour\" Un formulaire s'ouvre vous permettant de configurer la cr\u00e9ation de la story , l'intention qui sera \u00e9galement cr\u00e9\u00e9e, le type de r\u00e9ponse, etc. Dans le champs Add new Answer , saisissez une r\u00e9ponse par exemple \"quelle belle journ\u00e9e!\" Terminez avec Create Story Il est possible de r\u00e9pondre par plusieurs messages, ou des messages plus \u00e9volu\u00e9s comme des images, des liens, des boutons d' Action de mani\u00e8re \u00e0 continuer le dialogue, etc. La section Tock Studio du manuel utilisateur Tock vous en apprendra plus.","title":"Cr\u00e9er un parcours"},{"location":"getting-started/start-studio/#tester-le-bot","text":"Il est maintenant temps de tester le bot et votre premier parcours! Allez dans Test Test the bot Dites \"bonjour\" \ud83d\ude4b, le bot vous r\u00e9pond \ud83e\udd16 Si le bot r\u00e9pond qu'il n'a pas compris, c'est certainement un probl\u00e8me de qualification. Vous pouvez v\u00e9rifier que la story et/ou l' intention ont bien \u00e9t\u00e9 cr\u00e9\u00e9s en allant dans Build Search Stories . V\u00e9rifiez aussi que vous \u00eates sur la bonne application et la bonne lanque (au cas o\u00f9 vous en auriez cr\u00e9\u00e9 plusieurs) pour faire le test : ils sont visibles en haut \u00e0 droite de l'interface. Si malgr\u00e9 tout le bot r\u00e9pond qu'il ne comprend pas, peut-\u00eatre n'avez-vous pas saisi exactement la phrase utilis\u00e9e \u00e0 la cr\u00e9ation de la story , et le bot ne fait pas encore le lien avec cette seconde phrase. Dans le paragraphe suivant, vous verrez comment am\u00e9liorer la compr\u00e9hension du bot en qualifiant plus de phrases utilisateur. Si vous obtenez un message d'erreur technique, il s'agit probablement d'une erreur de configuration du connecteur.","title":"Tester le bot"},{"location":"getting-started/start-studio/#ameliorer-la-comprehension","text":"En saisissant des phrases un peu diff\u00e9rentes dans l'\u00e9cran Test the bot , vous pouvez constater qu'il ne comprend pas encore tr\u00e8s bien votre langage - m\u00eame lorsque les phrases sont proches de celle saisie \u00e0 la cr\u00e9ation de la story . C'est normal. Le mod\u00e8le conversationnel et la partie NLU de Tock s'enrichissent progressivement de phrases qualifi\u00e9es pour alimenter les algorithmes et donner des r\u00e9sultats de plus en plus pertinents. Les premiers essais peuvent \u00eatre d\u00e9cevants, mais souvent apr\u00e8s quelques qualifications, voire une ou deux dizaines de phrases qualifi\u00e9es si besoin, votre bot vous comprend d\u00e9j\u00e0 bien mieux. Allez dans NLU Inbox Vous voyez les phrases que vous avez saisies, et comment le bot les a interpr\u00eat\u00e9es. Pour chacune s'affichent l'intention reconnue, la langue ainsi que le score (que se donnent les algorithmes selon leur niveau de confiance sur cette phrase). Choisissez quelques phrases, pour chacune s\u00e9lectionnez la bonne intention puis Validate Retournez dans Test Test the bot V\u00e9rifiez que le bot comprend mieux ces phrases, et m\u00eames d'autres un peu diff\u00e9rentes alors que vous ne les avez pas qualifi\u00e9es explicitement!","title":"Am\u00e9liorer la compr\u00e9hension"},{"location":"getting-started/start-studio/#creer-dautres-parcours-optionnel","text":"Pour aller un peu plus loin avec les stories Tock, vous pouvez cr\u00e9er d'autres parcours et les tester directement dans Tock Studio . Le bot vous r\u00e9pond alors selon l'intention d\u00e9clench\u00e9e, sans autre forme de navigation que le fil que vous donnez \u00e0 la conversation. C'est la magie du conversationnel : le langage naturel est la seule navigation, et l'utilisateur est soustrait aux liens et menus traditionnellement impos\u00e9s par les interfaces Web ou mobiles. Remarque : si vous preniez le temps de cr\u00e9er de tr\u00e8s nombreuses stories , vous contasteriez peut-\u00eatre quelques effets ind\u00e9sirables propres au mode de fonctionnement des mod\u00e8les et algorithmes NLU . Par exemple, un tr\u00e8s grand nombre d'intentions et d'entit\u00e9s peut rendre plus difficile leur d\u00e9tection. On recommande souvent de commencer par cr\u00e9er des bots d\u00e9di\u00e9s \u00e0 un domaine fonctionnel limit\u00e9, facilitant son apprentissage en focalisant le mod\u00e8le sur ce domaine. Qualifier beaucoup de phrases permet en g\u00e9n\u00e9ral d'am\u00e9liorer la compr\u00e9hension, mais \u00e0 l'inverse qualifier trop de phrases (ou trop proches) peut sur-entra\u00eener le mod\u00e8le pour une intention, avec pour effet de r\u00e9duire la reconnaissance des phrases un peu diff\u00e9rentes. Retenez que la conception et la maintenance des mod\u00e8les conversationnels est un sujet complexe qui n\u00e9cessite de l'apprentissage (du bot mais aussi de ceux qui le construisent), de r\u00e9-\u00e9valuer et r\u00e9-adapter r\u00e9guli\u00e8rement ces mod\u00e8les aux besoins et aux nouvelles demandes des utilisateurs.","title":"Cr\u00e9er d'autres parcours (optionnel)"},{"location":"getting-started/start-studio/#felicitations","text":"Vous venez de cr\u00e9er votre premier bot conversationnel avec Tock. Comme vous avez pu vous en apercevoir, quelques minutes suffisent, sans connaissances techniques approfondies, pour cr\u00e9er des parcours conversationnels simples sans \u00e9crire ni d\u00e9ployer de code.","title":"F\u00e9licitations!"},{"location":"getting-started/start-studio/#continuer","text":"Dans les sections suivantes vous apprendez \u00e0 : Configurer le bot pour le canal Slack (requiert un compte Slack) Configurer le bot pour le canal Messenger (requiert un compte Facebook) Cr\u00e9er des parcours programm\u00e9s en Kotlin , ouvrant la voie \u00e0 des comportements complexes et l'int\u00e9gration d'API tierces si besoin D\u00e9ployer une plateforme Tock en quelques minutes avec Docker Pour en savoir plus sur Tock Studio , les fonctionnalit\u00e9s et les modes de d\u00e9ploiement de Tock, vous pouvez aussi parcourir le manuel utilisateur , plus complet.","title":"Continuer..."},{"location":"user-manual/concepts/","text":"Concepts conversationnels pour Tock Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles. Notions pour Tock Intentions TODO Entit\u00e9s TODO Actions TODO Messages et phrases (ou sentences ) TODO Parcours (ou stories ) Un parcours ou story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\". TODO Connecteur TODO Mod\u00e8le TODO Application TODO Termes correspondances Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Watson Intent Intent Intent Entity Entity Action Message Sentence Query Utterance / Slot Story Connector Integration Model Dialog model Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal. Continuer... Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Concepts"},{"location":"user-manual/concepts/#concepts-conversationnels-pour-tock","text":"Cette page pr\u00e9sente et vulgarise les principaux concepts et la terminologie conversationnelle utilis\u00e9e dans Tock et sa documentation. Un tableau propose \u00e9galement des \u00e9quivalences et termes similaires dans d'autres solutions conversationnelles.","title":"Concepts conversationnels pour Tock"},{"location":"user-manual/concepts/#notions-pour-tock","text":"","title":"Notions pour Tock"},{"location":"user-manual/concepts/#intentions","text":"TODO","title":"Intentions"},{"location":"user-manual/concepts/#entites","text":"TODO","title":"Entit\u00e9s"},{"location":"user-manual/concepts/#actions","text":"TODO","title":"Actions"},{"location":"user-manual/concepts/#messages-et-phrases-ou-sentences","text":"TODO","title":"Messages et phrases (ou sentences)"},{"location":"user-manual/concepts/#parcours-ou-stories","text":"Un parcours ou story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\". TODO","title":"Parcours (ou stories)"},{"location":"user-manual/concepts/#connecteur","text":"TODO","title":"Connecteur"},{"location":"user-manual/concepts/#modele","text":"TODO","title":"Mod\u00e8le"},{"location":"user-manual/concepts/#application","text":"TODO","title":"Application"},{"location":"user-manual/concepts/#termes-correspondances","text":"Le tableau ci-dessous propose des correspondances entre les termes utilis\u00e9s dans Tock et ceux d'autres solutions conversationnelles : Tock DialogFlow Alexa Watson Intent Intent Intent Entity Entity Action Message Sentence Query Utterance / Slot Story Connector Integration Model Dialog model Application Project / Agent Skill La documentation des connecteurs Tock donne \u00e9galement la correspondance avec d'autres termes propres \u00e0 tel ou tel canal.","title":"Termes &amp; correspondances"},{"location":"user-manual/concepts/#continuer","text":"Vous pouvez maintenant entamer le chapitre suivant : Interfaces Tock Studio .","title":"Continuer..."},{"location":"user-manual/connectors/","text":"Les connecteurs Tock Notion de connecteur Tock Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication textuel ou vocal externe. Mis \u00e0 part le type connecteur de test , d\u00e9di\u00e9 aux tests via l'interface Tock Studio , les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis lui ajouter un nouveau connecteur par la suite. Gouvernance des mod\u00e8les et donn\u00e9es Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux. Les types de connecteurs fournis avec Tock Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc. Messenger Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur github, o\u00f9 vous retrouverez les sources et le README du connecteur. Slack Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur github, o\u00f9 vous retrouverez les sources et le README du connecteur. Google Assistant / Google Home Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur github. Alexa / Echo Canal : Alexa Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur github. Rocket.Chat Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur github. WhatsApp Canal : WhatsApp Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur github. Teams Canal : Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur github. Business Chat / Messages Canal : Business Chat Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur github. Twitter Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock en d\u00e9veloppement Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur github. Web TODO - Work in progress Test Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test Test the bot ). D\u00e9velopper son propre connecteur Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework de la documentation Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"Les connecteurs"},{"location":"user-manual/connectors/#les-connecteurs-tock","text":"","title":"Les connecteurs Tock"},{"location":"user-manual/connectors/#notion-de-connecteur-tock","text":"Un connecteur Tock permet d'int\u00e9grer un bot \u00e0 un canal de communication textuel ou vocal externe. Mis \u00e0 part le type connecteur de test , d\u00e9di\u00e9 aux tests via l'interface Tock Studio , les connecteurs sont associ\u00e9s \u00e0 des canaux externes \u00e0 la plateforme Tock. Tout l'int\u00e9r\u00eat des connecteurs Tock r\u00e9side dans la possibilit\u00e9 de d\u00e9velopper des assistants conversationnels ind\u00e9pendamment du ou des canaux utilis\u00e9s pour lui parler. Il est ainsi possible de cr\u00e9er un bot pour un canal, puis lui ajouter un nouveau connecteur par la suite.","title":"Notion de connecteur Tock"},{"location":"user-manual/connectors/#gouvernance-des-modeles-et-donnees","text":"Dans une optique de gouvernance des mod\u00e8les et donn\u00e9es conversationnelles, l'architecture en connecteurs Tock pr\u00e9sente plusieurs avantages : Le mod\u00e8le est construit dans Tock, il n'est pas partag\u00e9 via les connecteurs Le choix des connecteurs d'un bot permet de maitriser la propagation (ou non) des conversations Par exemple, pour un bot interne \u00e0 une entreprise, on peut choisir de n'utiliser que des connecteurs vers des canaux propres (site Web, etc.) ou internes \u00e0 l'entreprise (applications d'entreprise, espace pro sur un t\u00e9l\u00e9phone Android, etc.). M\u00eame si un bot est connect\u00e9 \u00e0 plusieurs canaux/partenaires externes, seule la plateforme Tock poss\u00e8de l'ensemble des conversations sur tous ces canaux.","title":"Gouvernance des mod\u00e8les et donn\u00e9es"},{"location":"user-manual/connectors/#les-types-de-connecteurs-fournis-avec-tock","text":"Tock fournit de nombreux connecteurs pour diff\u00e9rents types de canaux (voir ci-dessous). De nouveaux connecteurs sont r\u00e9guli\u00e8rement ajout\u00e9s \u00e0 la plateforme, en fonction des besoins projets mais aussi du calendrier d'ouverture aux bots des canaux grand public. Exemples : arriv\u00e9e de Google Home en France en 2017, Alexa en 2018, ouverture des API WhatsApp puis Business Chat en 2019, etc.","title":"Les types de connecteurs fournis avec Tock"},{"location":"user-manual/connectors/#messenger","text":"Canal : Facebook Messenger Type : texte (+ voix via l'upload de messages vocaux) Status : connecteur Tock utilis\u00e9 en production depuis 2016 Le guide Connecter son bot \u00e0 Messenger explique comment int\u00e9grer un bot Tock avec une page Facebook / Messenger . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-messenger sur github, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Messenger"},{"location":"user-manual/connectors/#slack","text":"Canal : Slack Type : texte Status : connecteur Tock utilis\u00e9 hors production Le guide Connecter son bot \u00e0 Slack explique comment int\u00e9grer un bot Tock avec une cha\u00eene Slack . Pour en savoir plus sur ce connecteur, vous pouvez aussi vous rendre dans le dossier connector-slack sur github, o\u00f9 vous retrouverez les sources et le README du connecteur.","title":"Slack"},{"location":"user-manual/connectors/#google-assistant-google-home","text":"Canal : Google Assistant / Google Home Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2017 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-ga sur github.","title":"Google Assistant / Google Home"},{"location":"user-manual/connectors/#alexa-echo","text":"Canal : Alexa Type : voix Status : connecteur Tock utilis\u00e9 en production depuis 2018 Remarque importante : dans le cas d'Alexa, le mod\u00e8le NLP est forc\u00e9ment construit et h\u00e9berg\u00e9 chez Amazon. Seul la partie framework conversationel de Tock peut \u00eatre utilis\u00e9e. Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-alexa sur github.","title":"Alexa / Echo"},{"location":"user-manual/connectors/#rocketchat","text":"Canal : Rocket.Chat Type : texte Status : \u00e0 pr\u00e9ciser Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-rocketchat sur github.","title":"Rocket.Chat"},{"location":"user-manual/connectors/#whatsapp","text":"Canal : WhatsApp Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-whatsapp sur github.","title":"WhatsApp"},{"location":"user-manual/connectors/#teams","text":"Canal : Teams Type : texte + voix Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-teams sur github.","title":"Teams"},{"location":"user-manual/connectors/#business-chat-messages","text":"Canal : Business Chat Type : texte Status : connecteur Tock utilis\u00e9 en production depuis 2019 Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-businesschat sur github.","title":"Business Chat / Messages"},{"location":"user-manual/connectors/#twitter","text":"Canal : Twitter (messages priv\u00e9s) Type : texte Status : connecteur Tock en d\u00e9veloppement Pour en savoir plus sur ce connecteur, voir ses sources et son README dans le dossier connector-twitter sur github.","title":"Twitter"},{"location":"user-manual/connectors/#web","text":"TODO - Work in progress","title":"Web"},{"location":"user-manual/connectors/#test","text":"Ce connecteur est interne \u00e0 Tock, il sert \u00e0 dialoguer avec un bot directement dans l'interface Tock Studio (vue Test Test the bot ).","title":"Test"},{"location":"user-manual/connectors/#developper-son-propre-connecteur","text":"Il est possible de cr\u00e9er son propre connecteur Tock, par exemple pour interfacer un bot Tock avec un canal propre \u00e0 l'organisation (souvent un site Web ou une application mobile sp\u00e9cifiques), ou bien quand un canal grand public s'ouvre aux bots conversationnels et que le connecteur Tock n'existe pas encore. La section Bot Framework de la documentation Tock donne des indications pour impl\u00e9menter son propre connecteur.","title":"D\u00e9velopper son propre connecteur"},{"location":"user-manual/dev/","text":"D\u00e9velopper des bots Deux possibilit\u00e9s de d\u00e9veloppement Pour aller plus loin dans le d\u00e9veloppement d'un assistant, il va n\u00e9cessaire d'utiliser des scripts ou du code. Assistant Tock Dans ce mode, vous acc\u00e8s \u00e0 l'int\u00e9gralit\u00e9 des fonctionnalit\u00e9s que met \u00e0 disposition Tock pour d\u00e9velopper un Bot. C'est de cette mani\u00e8re que sont d\u00e9velopp\u00e9s aujourd'hui les bots publi\u00e9s par les concepteurs de Tock. Cependant la phase de mise en place de la solution est assez complexe. Il est en effet n\u00e9cessaire : D'installer une stack docker sur son poste ou sur son serveur De permettre la connexion partag\u00e9e \u00e0 la base MongoDB entre les poste de dev et la stack Tock utilis\u00e9e De ma\u00eetriser le langage Kotlin Assistant via API Si vous souhaitez \u00e9valuer la solution Tock, il est conseill\u00e9 d'utiliser les APIs (actuellement en phase b\u00e9ta) mises \u00e0 disposition par Tock. Deux options s'offrent \u00e0 vous. TODO Tock Bot API : Architectures Le mode WebSocket Le mode WebHook Utiliser l'API Tock Bot Framework : Architecture Le bus Tock Les types de Message StoryHandler StoryDef NlpListener ...","title":"D\u00e9velopper des bots"},{"location":"user-manual/dev/#developper-des-bots","text":"","title":"D\u00e9velopper des bots"},{"location":"user-manual/dev/#deux-possibilites-de-developpement","text":"Pour aller plus loin dans le d\u00e9veloppement d'un assistant, il va n\u00e9cessaire d'utiliser des scripts ou du code.","title":"Deux possibilit\u00e9s de d\u00e9veloppement"},{"location":"user-manual/dev/#assistant-tock","text":"Dans ce mode, vous acc\u00e8s \u00e0 l'int\u00e9gralit\u00e9 des fonctionnalit\u00e9s que met \u00e0 disposition Tock pour d\u00e9velopper un Bot. C'est de cette mani\u00e8re que sont d\u00e9velopp\u00e9s aujourd'hui les bots publi\u00e9s par les concepteurs de Tock. Cependant la phase de mise en place de la solution est assez complexe. Il est en effet n\u00e9cessaire : D'installer une stack docker sur son poste ou sur son serveur De permettre la connexion partag\u00e9e \u00e0 la base MongoDB entre les poste de dev et la stack Tock utilis\u00e9e De ma\u00eetriser le langage Kotlin","title":"Assistant Tock"},{"location":"user-manual/dev/#assistant-via-api","text":"Si vous souhaitez \u00e9valuer la solution Tock, il est conseill\u00e9 d'utiliser les APIs (actuellement en phase b\u00e9ta) mises \u00e0 disposition par Tock. Deux options s'offrent \u00e0 vous. TODO Tock Bot API : Architectures Le mode WebSocket Le mode WebHook Utiliser l'API Tock Bot Framework : Architecture Le bus Tock Les types de Message StoryHandler StoryDef NlpListener ...","title":"Assistant via API"},{"location":"user-manual/i18n/","text":"Traduire et moduler les r\u00e9ponses du bot Activation La framework Tock met \u00e0 disposition un framework complet d'internationalisation. Il est d\u00e9sactiv\u00e9 par d\u00e9faut pour le mode \"Bot int\u00e9gr\u00e9\". Pour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot : Translator . enabled = true ou de passer la propri\u00e9t\u00e9 -Dtock_i18n_enabled=true \u00e0 la JVM. il est activ\u00e9 par d\u00e9faut pour le mode \"Bot API\". Utilisation dans le code Principe de fonctionnement Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( Arrival at {0} , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration : Format support\u00e9 Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( There {0,choice,0#are no files|1#is one file|1 are {0,number,integer} files}. , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( Departure at {0} , departureDateTime by timeFormat ) Locale de l'utilisateur Quand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement utilis\u00e9 comme locale par Tock. Si il n'y a pas d'indication de locale, c'est la valeur defaultLocale qui est pris en compte. Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9 -Dtock_default_locale=fr Enfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH Points d'attention Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( There are $nb files ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( There are $nb files . raw ) //CORRECT send ( There are {0} files , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( my_unique_key , There are {0} files , nb )) Tester l'internationalisation Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( Recherche , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( Quand souhaitez-vous partir? ) } } Interface d'administration Les diff\u00e9rentes variantes Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques : par type de connecteur (Messenger, Google Assistant, Slack, etc.) par type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas des parcours voix uniquement. Enfin, vous pouvez sp\u00e9cifier des alternatives . Dans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur. Import et export des donn\u00e9es Une fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les libell\u00e9s indiqu\u00e9s comme valid\u00e9s sont pris en compte.","title":"Multilingue / i18n"},{"location":"user-manual/i18n/#traduire-et-moduler-les-reponses-du-bot","text":"","title":"Traduire et moduler les r\u00e9ponses du bot"},{"location":"user-manual/i18n/#activation","text":"La framework Tock met \u00e0 disposition un framework complet d'internationalisation. Il est d\u00e9sactiv\u00e9 par d\u00e9faut pour le mode \"Bot int\u00e9gr\u00e9\". Pour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot : Translator . enabled = true ou de passer la propri\u00e9t\u00e9 -Dtock_i18n_enabled=true \u00e0 la JVM. il est activ\u00e9 par d\u00e9faut pour le mode \"Bot API\".","title":"Activation"},{"location":"user-manual/i18n/#utilisation-dans-le-code","text":"","title":"Utilisation dans le code"},{"location":"user-manual/i18n/#principe-de-fonctionnement","text":"Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : send ( Arrival at {0} , time ) est un code valide que le module soit activ\u00e9 ou non. Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement. Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es : Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot) et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 app_arrivals_Arrival at {0} o\u00f9 app est le namespace et arrivals l'intention principale de la story. Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la langue demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte) Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la langue courante Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :","title":"Principe de fonctionnement"},{"location":"user-manual/i18n/#format-supporte","text":"Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe MessageFormat en java. Cela inclut le support de ChoiceFormat : send ( There {0,choice,0#are no files|1#is one file|1 are {0,number,integer} files}. , 2 ) Par ailleurs, Tock met \u00e0 disposition une extension by pour les dates qui permet d'indiquer un format dans les param\u00e8tres : send ( Departure at {0} , departureDateTime by timeFormat )","title":"Format support\u00e9"},{"location":"user-manual/i18n/#locale-de-lutilisateur","text":"Quand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte. Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement utilis\u00e9 comme locale par Tock. Si il n'y a pas d'indication de locale, c'est la valeur defaultLocale qui est pris en compte. Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9 -Dtock_default_locale=fr Enfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame : userPreferences . locale = Locale . FRENCH","title":"Locale de l'utilisateur"},{"location":"user-manual/i18n/#points-dattention","text":"Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin, sont \u00e0 bannir sous peine de mauvaises surprises. Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9. send ( There are $nb files ) //DANGER!! mais pose probl\u00e8me si il est activ\u00e9. En effet, un nouveau libell\u00e9 sera cr\u00e9\u00e9 pour chaque valeur diff\u00e9rente de la variable nb ! Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez les m\u00e9thodes BotBus.sendRaw , BotBus.endRaw ou String.raw send ( There are $nb files . raw ) //CORRECT send ( There are {0} files , nb ) //FORMAT A SUIVRE Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. Si vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode i18nKey : send ( i18nKey ( my_unique_key , There are {0} files , nb ))","title":"Points d'attention"},{"location":"user-manual/i18n/#tester-linternationalisation","text":"Un exemple de dispositif de test est disponible dans le code source du bot d'exemple Il est n\u00e9cessaire d'\u00e9tendre l'extension de test pour ensuite indiquer la correspondance des libell\u00e9s \u00e0 tester. Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( Recherche , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( Quand souhaitez-vous partir? ) } }","title":"Tester l'internationalisation"},{"location":"user-manual/i18n/#interface-dadministration","text":"","title":"Interface d'administration"},{"location":"user-manual/i18n/#les-differentes-variantes","text":"Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot. Il est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques : par type de connecteur (Messenger, Google Assistant, Slack, etc.) par type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas des parcours voix uniquement. Enfin, vous pouvez sp\u00e9cifier des alternatives . Dans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur.","title":"Les diff\u00e9rentes variantes"},{"location":"user-manual/i18n/#import-et-export-des-donnees","text":"Une fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les libell\u00e9s indiqu\u00e9s comme valid\u00e9s sont pris en compte.","title":"Import et export des donn\u00e9es"},{"location":"user-manual/install/","text":"Installation Tock Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit ici d'\u00e9voquer le cas d'une installation en production, les composants, les flux, etc. ainsi que de partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock . Architecture fonctionnelle g\u00e9n\u00e9rale Deux composants majeurs sont disponibles, le moteur NLU (Natural Language Processing) et le framework conversationnel qui int\u00e8gre les services NLU et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack. Pour en savoir plus, voir Tock Studio et Les connecteurs . La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente. Installation (avec Docker) Les informations ci-dessous concernent l'installation avec Docker . En analysant les descripteurs Docker et Docker Compose fournis (les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker. Composants Tock est compos\u00e9 par d\u00e9faut de plusieurs images dockers et d'une base de donn\u00e9e, MongoDB . Un exemple de configuration compl\u00e8te sous forme de fichier docker-compose est disponible dans le projet tock-docker : docker-compose-bot-open-data.yml Si vous souhaitez utiliser docker-compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple d'environnement de d\u00e9velopement. En particulier, la configuration des instances MongoDB devra \u00eatre revue attentivement. MongoDB La base Mongo doit \u00eatre configur\u00e9e \"en replica set\", c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB. Liste et r\u00f4les des images Docker Voici les images composants Tock. Aucune de ces images ne doit \u00eatre expos\u00e9e \u00e0 l'ext\u00e9rieur par d\u00e9faut. tock/bot_admin : l'interface d'administration de Tock. tock/kotlin_compiler : Une image docker facultative qui permet de compiler les scripts du bot via l'interface d'administration. tock/build_worker : L'image docker qui permet de reconstruire les mod\u00e8les NLP quand cela se r\u00e9v\u00e8le n\u00e9cessaire. tock/nlp_api Permet au bot d'analyser les phrases \u00e0 partir des mod\u00e8les construits via l'interface d'administration. tock/bot_api Permet de d\u00e9velopper un bot en mode \"API\". Met \u00e0 disposition une API qui sera utilis\u00e9e pour le d\u00e9veloppement du ou des bots. tock/duckling Permet d'analyser et de valoriser les dates et les types primitifs en utilisant le projet Duckling . Enfin bien entendu, il est n\u00e9cessaire d'installer une image repr\u00e9sentant le bot lui-m\u00eame, image qui doit \u00eatre accessible de l'ext\u00e9rieur. Un exemple de configuration de cette derni\u00e8re image se trouve dans le fichier docker-compose-bot-open-data.yml . Sch\u00e9ma des flux Pour une stack uniquement NLU : Pour une stack exposant l'API BOT : Pour une stack int\u00e9grant un Bot Tock : Recommandations pour la production Configuration minimale Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. En particulier, plus vos mod\u00e8les sont importants, plus il sera n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les dans l'image tock/build_worker . Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions comportant une vingtaine d'entit\u00e9s chaque n\u00e9cessitera de provisionner environ 8Go de RAM pour l'image tock/build_worker . Cependant des mod\u00e8les importants, mais avec peu d'entit\u00e9s, tiennent facilement en 1Go de RAM. Configuration m\u00e9moire des JVMs Pour garantir que les instances dockers ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire disponible pour la JVM en suivant l'exemple suivant: JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m Haute disponibilit\u00e9 Autant il est important de s'assurer qu'une seule instance est install\u00e9e pour tock/build_worker - une seule instance est \u00e9galement recommand\u00e9e pour tock/bot_admin et tock/kotlin_compiler -, autant il est recommand\u00e9 d'installer plusieurs instances du bot mais \u00e9galement de tock/nlp_api et de tock/duckling afin de s'assurer d'une haute disponibilit\u00e9. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir. Authentification Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le \"par propri\u00e9t\u00e9\", qui est utilis\u00e9 par d\u00e9faut. Le code est disponible ici : PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par la classe GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur un token JWT pour une configuration Aws: AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question! Configuration de proxy HTTP L'ajout des propri\u00e9t\u00e9s syst\u00e8me java correspondantes https.proxyHost , http.proxyHost et http.nonProxyHosts est la m\u00e9thode recommand\u00e9e pour configurer un proxy. Encryption et Obfuscation Encryption Il est recommand\u00e9 de d\u00e9ployer vos MongoDB en mode encrypt\u00e9 . Vous pouvez cependant ajouter une encryption applicative facultative de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui vous permet d'indiquer un mot de passe permettant d'encrypter et de d\u00e9crypter ces champs - par d\u00e9faut Tock encrypte toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles si ce mot de passe est sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, consultez le code source . Obfuscation Par ailleurs, il peut \u00eatre souhaitable que certaines phrases soient affich\u00e9es dans les logs ou dans l'interface d'administration de mani\u00e8re obfusqu\u00e9e . Ce serait par exemple le cas de num\u00e9ros confidentiels de cartes de fid\u00e9lit\u00e9 qui ne devraient \u00eatre lues, ni par vos administrateurs syst\u00e8mes, ni par les utilisateurs de l'interface d'administration. Tock met \u00e0 disposition un syst\u00e8me bas\u00e9 sur les expressions r\u00e9guli\u00e8res dont l'interface de base est StringObfuscator . Monitoring Logs Tock utilise SLF4J . Ligne de vie L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck Contact Pour toute question ou remarque, n'h\u00e9sitez pas \u00e0 nous contacter sur Gitter . Nous enrichirons bient\u00f4t cette page, notamment d'informations et de conseils sp\u00e9cifiques aux d\u00e9ploiements Cloud .","title":"Installation"},{"location":"user-manual/install/#installation-tock","text":"Ce chapitre pr\u00e9sente les diff\u00e9rentes options d'installation de Tock. En particulier, il s'agit ici d'\u00e9voquer le cas d'une installation en production, les composants, les flux, etc. ainsi que de partager quelques retours d'exp\u00e9rience sur les performances, la r\u00e9silience, la capacit\u00e9 de Tock \u00e0 monter en charge, les d\u00e9ploiementsde type Cloud , la supervision, etc. Si vous cherchez seulement \u00e0 tester Tock avec des donn\u00e9es non sensibles, vous pouvez pr\u00e9f\u00e9rer utiliser la plateforme de d\u00e9monstration Tock .","title":"Installation Tock"},{"location":"user-manual/install/#architecture-fonctionnelle-generale","text":"Deux composants majeurs sont disponibles, le moteur NLU (Natural Language Processing) et le framework conversationnel qui int\u00e8gre les services NLU et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack. Pour en savoir plus, voir Tock Studio et Les connecteurs . La plateforme NLU est ind\u00e9pendante de la partie conversationnelle. Il est possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLU seule est pertinente.","title":"Architecture fonctionnelle g\u00e9n\u00e9rale"},{"location":"user-manual/install/#installation-avec-docker","text":"Les informations ci-dessous concernent l'installation avec Docker . En analysant les descripteurs Docker et Docker Compose fournis (les Dockerfile et docker-compose.yml ) on peut facilement concevoir une installation sans Docker.","title":"Installation (avec Docker)"},{"location":"user-manual/install/#composants","text":"Tock est compos\u00e9 par d\u00e9faut de plusieurs images dockers et d'une base de donn\u00e9e, MongoDB . Un exemple de configuration compl\u00e8te sous forme de fichier docker-compose est disponible dans le projet tock-docker : docker-compose-bot-open-data.yml Si vous souhaitez utiliser docker-compose en production, merci de lire cet article et de revoir la configuration, qui est uniquement donn\u00e9e dans le projet tock-docker \u00e0 titre d'exemple d'environnement de d\u00e9velopement. En particulier, la configuration des instances MongoDB devra \u00eatre revue attentivement.","title":"Composants"},{"location":"user-manual/install/#mongodb","text":"La base Mongo doit \u00eatre configur\u00e9e \"en replica set\", c'est \u00e0 dire avec au minimum 3 instances d\u00e9ploy\u00e9es. C'est obligatoire car Tock utilise la fonctionnalit\u00e9 des Change Streams qui a comme pr\u00e9-requis l'installation en replica set. Il s'agit \u00e9galement d'une bonne pratique afin d'assurer une haute disponibilit\u00e9 de la base de donn\u00e9es. Un tutoriel d'installation en replica set est disponible sur le site de MongoDB.","title":"MongoDB"},{"location":"user-manual/install/#liste-et-roles-des-images-docker","text":"Voici les images composants Tock. Aucune de ces images ne doit \u00eatre expos\u00e9e \u00e0 l'ext\u00e9rieur par d\u00e9faut. tock/bot_admin : l'interface d'administration de Tock. tock/kotlin_compiler : Une image docker facultative qui permet de compiler les scripts du bot via l'interface d'administration. tock/build_worker : L'image docker qui permet de reconstruire les mod\u00e8les NLP quand cela se r\u00e9v\u00e8le n\u00e9cessaire. tock/nlp_api Permet au bot d'analyser les phrases \u00e0 partir des mod\u00e8les construits via l'interface d'administration. tock/bot_api Permet de d\u00e9velopper un bot en mode \"API\". Met \u00e0 disposition une API qui sera utilis\u00e9e pour le d\u00e9veloppement du ou des bots. tock/duckling Permet d'analyser et de valoriser les dates et les types primitifs en utilisant le projet Duckling . Enfin bien entendu, il est n\u00e9cessaire d'installer une image repr\u00e9sentant le bot lui-m\u00eame, image qui doit \u00eatre accessible de l'ext\u00e9rieur. Un exemple de configuration de cette derni\u00e8re image se trouve dans le fichier docker-compose-bot-open-data.yml .","title":"Liste et r\u00f4les des images Docker"},{"location":"user-manual/install/#schema-des-flux","text":"Pour une stack uniquement NLU : Pour une stack exposant l'API BOT : Pour une stack int\u00e9grant un Bot Tock :","title":"Sch\u00e9ma des flux"},{"location":"user-manual/install/#recommandations-pour-la-production","text":"","title":"Recommandations pour la production"},{"location":"user-manual/install/#configuration-minimale","text":"Le param\u00e8tre principal \u00e0 surveiller est la m\u00e9moire vive disponible. En particulier, plus vos mod\u00e8les sont importants, plus il sera n\u00e9cessaire d'augmenter la m\u00e9moire pour reconstruire les mod\u00e8les dans l'image tock/build_worker . Pour donner un ordre de grandeur, un mod\u00e8le de 50000 phrases avec plusieurs intentions comportant une vingtaine d'entit\u00e9s chaque n\u00e9cessitera de provisionner environ 8Go de RAM pour l'image tock/build_worker . Cependant des mod\u00e8les importants, mais avec peu d'entit\u00e9s, tiennent facilement en 1Go de RAM.","title":"Configuration minimale"},{"location":"user-manual/install/#configuration-memoire-des-jvms","text":"Pour garantir que les instances dockers ne d\u00e9passent pas la m\u00e9moire disponible, il est recommand\u00e9 de limiter la m\u00e9moire disponible pour la JVM en suivant l'exemple suivant: JAVA_ARGS =- Xmx1g - XX : MaxMetaspaceSize = 256 m","title":"Configuration m\u00e9moire des JVMs"},{"location":"user-manual/install/#haute-disponibilite","text":"Autant il est important de s'assurer qu'une seule instance est install\u00e9e pour tock/build_worker - une seule instance est \u00e9galement recommand\u00e9e pour tock/bot_admin et tock/kotlin_compiler -, autant il est recommand\u00e9 d'installer plusieurs instances du bot mais \u00e9galement de tock/nlp_api et de tock/duckling afin de s'assurer d'une haute disponibilit\u00e9. A forte charge - nous avons exp\u00e9riment\u00e9 plus de 80 req/s sur nos propres bots - le facteur limitant devient la base de donn\u00e9es MongoDB, qu'il faut alors redimensionner en cons\u00e9quence quand le besoin s'en fait sentir.","title":"Haute disponibilit\u00e9"},{"location":"user-manual/install/#authentification","text":"Tock supporte plusieurs syst\u00e8mes d'authentification pour l'interface d'administration. Il utilise les librairies vert.x correspondantes. Voici les syst\u00e8mes disponibles par d\u00e9faut : Un mod\u00e8le \"par propri\u00e9t\u00e9\", qui est utilis\u00e9 par d\u00e9faut. Le code est disponible ici : PropertyBasedAuthProvider Un mod\u00e8le OAuth2 dont un exemple est donn\u00e9 par la classe GithubOAuthProvider Un mod\u00e8le bas\u00e9 sur un token JWT pour une configuration Aws: AWSJWTAuthProvider Si ces mod\u00e8les ne correspondent pas \u00e0 votre besoin, il est relativement simple d'en d\u00e9velopper d'autres en se basant sur les exemples ci-dessus. N'h\u00e9sitez pas \u00e0 contribuer au projet et \u00e0 nous contacter pour toute question!","title":"Authentification"},{"location":"user-manual/install/#configuration-de-proxy-http","text":"L'ajout des propri\u00e9t\u00e9s syst\u00e8me java correspondantes https.proxyHost , http.proxyHost et http.nonProxyHosts est la m\u00e9thode recommand\u00e9e pour configurer un proxy.","title":"Configuration de proxy HTTP"},{"location":"user-manual/install/#encryption-et-obfuscation","text":"","title":"Encryption et Obfuscation"},{"location":"user-manual/install/#encryption","text":"Il est recommand\u00e9 de d\u00e9ployer vos MongoDB en mode encrypt\u00e9 . Vous pouvez cependant ajouter une encryption applicative facultative de certains champs en base de donn\u00e9es. C'est le r\u00f4le de la propri\u00e9t\u00e9 tock_encrypt_pass qui vous permet d'indiquer un mot de passe permettant d'encrypter et de d\u00e9crypter ces champs - par d\u00e9faut Tock encrypte toutes les donn\u00e9es utilisateurs jug\u00e9es sensibles si ce mot de passe est sp\u00e9cifi\u00e9. Pour plus de d\u00e9tails, consultez le code source .","title":"Encryption"},{"location":"user-manual/install/#obfuscation","text":"Par ailleurs, il peut \u00eatre souhaitable que certaines phrases soient affich\u00e9es dans les logs ou dans l'interface d'administration de mani\u00e8re obfusqu\u00e9e . Ce serait par exemple le cas de num\u00e9ros confidentiels de cartes de fid\u00e9lit\u00e9 qui ne devraient \u00eatre lues, ni par vos administrateurs syst\u00e8mes, ni par les utilisateurs de l'interface d'administration. Tock met \u00e0 disposition un syst\u00e8me bas\u00e9 sur les expressions r\u00e9guli\u00e8res dont l'interface de base est StringObfuscator .","title":"Obfuscation"},{"location":"user-manual/install/#monitoring","text":"","title":"Monitoring"},{"location":"user-manual/install/#logs","text":"Tock utilise SLF4J .","title":"Logs"},{"location":"user-manual/install/#ligne-de-vie","text":"L'url /healthcheck renvoie une code HTTP 200 si tout est correct. Pour certaines images, le ligne de vie peut ne pas \u00eatre pr\u00e9sente \u00e0 la racine. En particulier : Pour tock/admin , la ligne de vie est localis\u00e9e par d\u00e9faut dans /rest/admin/healthcheck Pour tock/nlp_api , la ligne de vie est /rest/nlp/healthcheck","title":"Ligne de vie"},{"location":"user-manual/install/#contact","text":"Pour toute question ou remarque, n'h\u00e9sitez pas \u00e0 nous contacter sur Gitter . Nous enrichirons bient\u00f4t cette page, notamment d'informations et de conseils sp\u00e9cifiques aux d\u00e9ploiements Cloud .","title":"Contact"},{"location":"user-manual/studio/","text":"Les interfaces Tock Studio Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue mais aussi des pages d\u00e9di\u00e9es \u00e0 des th\u00e8mes ou des fonctionnalit\u00e9s particuli\u00e8res : Ecrans et vues Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Zooms : Construire les mod\u00e8les conversationnels Voir aussi Cr\u00e9er un bot multilingue / Internationalisation Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Tock Studio"},{"location":"user-manual/studio/#les-interfaces-tock-studio","text":"Tock Studio regroupe l'ensemble des interfaces utilisateur, techniques et m\u00e9tier, permettant de concevoir les mod\u00e8les conversationnels, cr\u00e9er des parcours et des r\u00e9ponses, suivre les conversations, analyser les tendances, etc. Dans cette section, vous trouverez la description de chaque vue mais aussi des pages d\u00e9di\u00e9es \u00e0 des th\u00e8mes ou des fonctionnalit\u00e9s particuli\u00e8res : Ecrans et vues Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Zooms : Construire les mod\u00e8les conversationnels Voir aussi Cr\u00e9er un bot multilingue / Internationalisation Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Les interfaces Tock Studio"},{"location":"user-manual/tmp-vues/","text":"La composante NLP est ind\u00e9pendante de la partie conversationnelle. Il est donc possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations. Dans certain cas d'usage importants, comme l' Internet des objets , l'utilisation d'un mod\u00e8le NLP seule est pertinente. Une plateforme pour construire des mod\u00e8les d'analyse du langage naturel L'outil principal est constitu\u00e9 par une interface d'administration qui permet de qualifier des phrases afin de construire des mod\u00e8les de traitement automatique du langage naturel ( TALN ) :","title":"Tmp vues"},{"location":"user-manual/toc/","text":"Manuel utilisateur Tock Table des mati\u00e8res Concepts Interfaces Tock Studio : Ecrans et vues Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Zooms : Construire les mod\u00e8les conversationnels Voir aussi Cr\u00e9er un bot multilingue / Internationalisation D\u00e9veloppement : Tock Bot API : Tock Bot Framework : Tests Unitaires Les connecteurs Cr\u00e9er un bot multilingue / Internationalisation Installation","title":"Table des mati\u00e8res"},{"location":"user-manual/toc/#manuel-utilisateur-tock","text":"Table des mati\u00e8res Concepts Interfaces Tock Studio : Ecrans et vues Tock Studio : Interface g\u00e9n\u00e9rale Le menu Configuration Le menu NLU Le menu NLU QA Le menu Build Le menu Test Le menu Monitoring Zooms : Construire les mod\u00e8les conversationnels Voir aussi Cr\u00e9er un bot multilingue / Internationalisation D\u00e9veloppement : Tock Bot API : Tock Bot Framework : Tests Unitaires Les connecteurs Cr\u00e9er un bot multilingue / Internationalisation Installation","title":"Manuel utilisateur Tock"},{"location":"user-manual/dev/bot-api/","text":"Tock Bot API Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme NLU Tock d'une mani\u00e8re peu coupl\u00e9e car n'ayant pas acc\u00e8s \u00e0 la base de donn\u00e9es (MongoDB), contrairement au mode Bot Framework . C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Par exemple, seul le mode Bot API est autoris\u00e9 sur la plateforme de d\u00e9monstration publique Tock (pour des raisons de s\u00e9curit\u00e9 \u00e9videntes). Cette section de la documentation Tock pr\u00e9sente les diff\u00e9rentes API fournies par Tock, ainsi que des indications pour d\u00e9velopper en mode Bot API en Kotlin . Notez toutefois qu'il est possible de d\u00e9velopper dans n'importe quel langage via la Bot API - une documentation pour un autre langage devrait bient\u00f4t arriver. Une autre section pr\u00e9sente le mode Bot Framework , plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock. Les APIs de Tock Tock NLU API L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demotock-production-admin.vsct-prod.aws.vsct.fr/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html . Tock Studio API De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demotock-production-admin.vsct-prod.aws.vsct.fr/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html . Tock Bot API L'API permettant de d\u00e9velopper des bots Tock avec n'importe quel langage. Elle est aussi utilis\u00e9e pour d\u00e9velopper en modes WebHook et WebSocket en Kotlin, comme d\u00e9crit dans la documentation d\u00e9veloppeur ) est encore en d\u00e9veloppement (b\u00e9ta). Une documentation arrivera bient\u00f4t. D\u00e9velopper en mode Bot API en Kotlin Pr\u00e9-requis / Architecture Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. Le module bot-api est d\u00e9j\u00e0 d\u00e9ploy\u00e9 sur la plateforme de d\u00e9monstration Tock . Activer le mode WebSocket C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-websocket /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:tock-bot-api-websocket:19.3.2 Activer le mode WebHook Pour utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-webhook /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:tock-bot-api-webhook:19.3.2 Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock. Son URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration Bot Configurations de l'interface Tock Studio . Param\u00e9trer la cl\u00e9 d'API Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous). Cr\u00e9er des parcours en Kotlin Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte brut Format \"carte\" Formats sp\u00e9cfiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { start ( newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( greetings ) { // Intent greetings end ( Hello! ) // Raw text answer }, newStory ( location ) { // Intent location end ( newCard ( The title , A subtitle , newAttachment ( https://url-image.png ), newAction ( Action 1 ), newAction ( Action 2 , http://redirection ) // Anwser with a card - including text, image and actions ) ) }, newStory ( goodbye ) { // Intent goodbye end { // Answer with Messenger-specific button/quick reply buttonsTemplate ( Are you sure you want to leave? , nlpQuickReply ( Stay )) } }, unknownStory { end ( I don t understand :( ) // Default answer } ), http://localhost:8080 // Local platform URL (default host/port) ) } Tester avec la plateforme de d\u00e9monstration Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester le mode WebSocket directement sur la plateforme de d\u00e9monstration Tock . Pour cela, il suffit de remplacer la m\u00e9thode start par startWithDemo (sans pr\u00e9ciser l'adresse de la plateforme). D\u00e9velopper dans un autre langage Il est possible de d\u00e9velopper dans n'importe quel langage en programmant directement via l'API. TODO : contrat en cours de stabilisation documentation \u00e0 venir.","title":"Tock Bot API"},{"location":"user-manual/dev/bot-api/#tock-bot-api","text":"Le mode Bot API de Tock permet de d\u00e9velopper des bots en se connectant \u00e0 une plateforme NLU Tock d'une mani\u00e8re peu coupl\u00e9e car n'ayant pas acc\u00e8s \u00e0 la base de donn\u00e9es (MongoDB), contrairement au mode Bot Framework . C'est donc le mode de d\u00e9veloppement Tock recommand\u00e9 pour d\u00e9marrer, ainsi que dans des scenarios ou l'acc\u00e8s partag\u00e9 \u00e0 la base de donn\u00e9es serait un probl\u00e8me. Par exemple, seul le mode Bot API est autoris\u00e9 sur la plateforme de d\u00e9monstration publique Tock (pour des raisons de s\u00e9curit\u00e9 \u00e9videntes). Cette section de la documentation Tock pr\u00e9sente les diff\u00e9rentes API fournies par Tock, ainsi que des indications pour d\u00e9velopper en mode Bot API en Kotlin . Notez toutefois qu'il est possible de d\u00e9velopper dans n'importe quel langage via la Bot API - une documentation pour un autre langage devrait bient\u00f4t arriver. Une autre section pr\u00e9sente le mode Bot Framework , plus int\u00e9gr\u00e9 mais aussi plus coupl\u00e9 \u00e0 la plateforme Tock.","title":"Tock Bot API"},{"location":"user-manual/dev/bot-api/#les-apis-de-tock","text":"","title":"Les APIs de Tock"},{"location":"user-manual/dev/bot-api/#tock-nlu-api","text":"L'API NLU de Tock (reconnaissance du langage naturel) permet d'interroger programmatiquement le mod\u00e8le conversationnel et d'analyser une phrase. La documentation de l'API Tock NLU est disponible dans /api . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demotock-production-admin.vsct-prod.aws.vsct.fr/doc/ . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/index.html .","title":"Tock NLU API"},{"location":"user-manual/dev/bot-api/#tock-studio-api","text":"De m\u00eame, la documentation de l'API Tock Studio est disponible dans /api/admin . Vous pouvez retrouver cette documentation sur la plateforme de d\u00e9monstration Tock, \u00e0 l'adresse https://demotock-production-admin.vsct-prod.aws.vsct.fr/doc/admin.html . Si vous avez d\u00e9ploy\u00e9 une plateforme Tock en local avec les images docker fournies, vous pouvez retrouver cette documentation en ligne \u00e0 l'adresse http://localhost/doc/admin.html .","title":"Tock Studio API"},{"location":"user-manual/dev/bot-api/#tock-bot-api_1","text":"L'API permettant de d\u00e9velopper des bots Tock avec n'importe quel langage. Elle est aussi utilis\u00e9e pour d\u00e9velopper en modes WebHook et WebSocket en Kotlin, comme d\u00e9crit dans la documentation d\u00e9veloppeur ) est encore en d\u00e9veloppement (b\u00e9ta). Une documentation arrivera bient\u00f4t.","title":"Tock Bot API"},{"location":"user-manual/dev/bot-api/#developper-en-mode-bot-api-en-kotlin","text":"","title":"D\u00e9velopper en mode Bot API en Kotlin"},{"location":"user-manual/dev/bot-api/#pre-requis-architecture","text":"Pour utiliser le mode Bot API de Tock, un module sp\u00e9cifique doit \u00eatre d\u00e9ploy\u00e9 avec la plateforme. G\u00e9n\u00e9ralement appel\u00e9 bot-api dans les descripteurs Docker Compose par exemple, ce service a pour r\u00f4le : D'exposer la Bot API aux clients potentiels quelque soit leur langage de programmation D'accepter des connexions en WebSocket Le guide D\u00e9ployer Tock avec Docker ou encore le chapitre Installation montrent comment d\u00e9ployer ce module si n\u00e9cessaire. Le module bot-api est d\u00e9j\u00e0 d\u00e9ploy\u00e9 sur la plateforme de d\u00e9monstration Tock .","title":"Pr\u00e9-requis / Architecture"},{"location":"user-manual/dev/bot-api/#activer-le-mode-websocket","text":"C'est le mode \u00e0 privil\u00e9gier au d\u00e9marrage car le plus simple \u00e0 mettre en oeuvre. Pour utiliser le client websocket, il faut ajouter la d\u00e9pendance tock-bot-api-websocket \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-websocket /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:tock-bot-api-websocket:19.3.2","title":"Activer le mode WebSocket"},{"location":"user-manual/dev/bot-api/#activer-le-mode-webhook","text":"Pour utiliser le client WebHook , il faut ajouter la d\u00e9pendance tock-bot-api-webhook \u00e0 votre application/projet Kotlin . Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId tock-bot-api-webhook /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:tock-bot-api-webhook:19.3.2 Dans ce cas, contrairement au mode WebSocket , il faut que l'application/bot d\u00e9marr\u00e9e soit joignable par la plateforme Tock. Son URL doit \u00eatre indiqu\u00e9e dans le champ webhook url dans la vue Configuration Bot Configurations de l'interface Tock Studio .","title":"Activer le mode WebHook"},{"location":"user-manual/dev/bot-api/#parametrer-la-cle-dapi","text":"Dans Tock Studio , apr\u00e8s avoir configur\u00e9 un bot, allez dans Configuration Bot Configurations et copiez la cl\u00e9 d'API du bot auquel vous souhaitez vous connecter. Vous pourrez saisir/coller cette clef dans le code Kotlin (voir ci-dessous).","title":"Param\u00e9trer la cl\u00e9 d'API"},{"location":"user-manual/dev/bot-api/#creer-des-parcours-en-kotlin","text":"Pour le moment, les composants suivants sont support\u00e9s pour les r\u00e9ponses : Texte brut Format \"carte\" Formats sp\u00e9cfiques aux diff\u00e9rents canaux int\u00e9gr\u00e9s Voici un exemple de bot simple avec quelques parcours d\u00e9clar\u00e9s : fun main () { start ( newBot ( PUT-YOUR-TOCK-APP-API-KEY-HERE , // Get your app API key from Bot Configurations in Tock Studio newStory ( greetings ) { // Intent greetings end ( Hello! ) // Raw text answer }, newStory ( location ) { // Intent location end ( newCard ( The title , A subtitle , newAttachment ( https://url-image.png ), newAction ( Action 1 ), newAction ( Action 2 , http://redirection ) // Anwser with a card - including text, image and actions ) ) }, newStory ( goodbye ) { // Intent goodbye end { // Answer with Messenger-specific button/quick reply buttonsTemplate ( Are you sure you want to leave? , nlpQuickReply ( Stay )) } }, unknownStory { end ( I don t understand :( ) // Default answer } ), http://localhost:8080 // Local platform URL (default host/port) ) }","title":"Cr\u00e9er des parcours en Kotlin"},{"location":"user-manual/dev/bot-api/#tester-avec-la-plateforme-de-demonstration","text":"Plut\u00f4t que d\u00e9ployer se propre plateforme Tock, il est possible de tester le mode WebSocket directement sur la plateforme de d\u00e9monstration Tock . Pour cela, il suffit de remplacer la m\u00e9thode start par startWithDemo (sans pr\u00e9ciser l'adresse de la plateforme).","title":"Tester avec la plateforme de d\u00e9monstration"},{"location":"user-manual/dev/bot-api/#developper-dans-un-autre-langage","text":"Il est possible de d\u00e9velopper dans n'importe quel langage en programmant directement via l'API. TODO : contrat en cours de stabilisation documentation \u00e0 venir.","title":"D\u00e9velopper dans un autre langage"},{"location":"user-manual/dev/bot-framework/","text":"Le framework Tock en Kotlin Le Bot Framework Tock permet de d\u00e9velopper un bot en mode int\u00e9gr\u00e9, en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin . D\u00e9marrer avec le framework Documentation KDoc La documentation du framework au format KDoc est disponible ici . D\u00e9pendance bot-toolkit Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId bot-toolkit /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:bot-toolkit:19.3.2 Un bot est un ensemble de parcours (stories) Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( bot_open_data , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings . Une Story simple Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( greetings ) { send ( Bienvenue chez le Bot Open Data Sncf! :) ) end ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( greetings ) { //cleanup state resetDialogState () send ( Bienvenue chez le Bot Open Data Sncf! :) ) send ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) withMessenger { buttonsTemplate ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , postbackButton ( Itin\u00e9raires , search ), postbackButton ( D\u00e9parts , Departures ), postbackButton ( Arriv\u00e9es , Arrivals ) ) } withGoogleAssistant { gaMessage ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , Itin\u00e9raires , D\u00e9parts , Arriv\u00e9es ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant. D\u00e9marrer et connecter le bot Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration Bot Configurations Create a new configuration . Pour en savoir plus sur les diff\u00e9rents connecteurs, voir cette page . Aller plus loin Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire. Intentions secondaires Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef SearchDef ( search , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires. Manipuler les entit\u00e9s Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( location , destination ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef SearchDef ( search , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null - end ( Pour quelle destination? ) origin == null - end ( Pour quelle origine? ) departureDate == null - end ( Quand souhaitez-vous partir? ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef SearchDef ( search , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null - end ( Pour quelle destination? ) origin == null - end ( Pour quelle origine? ) departureDate == null - end ( Quand souhaitez-vous partir? ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine. Utiliser HandlerDef Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef SearchConnector ( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( De {0} \u00e0 {1} , o , d ) send ( D\u00e9part le {0} , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :( ) } else { send ( Voici la premi\u00e8re proposition : ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null . Utiliser ConnectorDef Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef SearchDef ( context ) { fun Section . title (): CharSequence = i18n ( {0} - {1} , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List Section ): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List Section ): ConnectorMessage = flexibleListTemplate ( sections . map { section - with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es. Utiliser StoryStep Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep : SimpleStoryStep A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps MyStep ( intent ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps MyStep ( intent ) { //(...) step = MyStep . a // l \u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas . Les StoryStep avec comportement Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep MyHandlerDef { //pas de comportement sp\u00e9cifique display , select { // la step select sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() - Any ? = { end ( I don t know yet how to select something ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() - Any ? = { end ( some perturbation ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep . Postback buttons quick replies Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( The bot is very limited! Only itineraries are supported :) , postbackButton ( Itineraries , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d \u00e9tendre l interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( The bot is very limited! Only itineraries are supported :) , postbackButton ( Itineraries , intent = search , //si aucune step n est indiqu\u00e9e, c est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin ) Tests Unitaires La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock. D\u00e9velopper son propre connecteur Il est possible de d\u00e9velopper son propre connecteur. Pour cela quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( test ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router - //main API router . post ( $path/message ). blockingHandler { context - //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l \u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l action callback . actions . add ( event ) //si c est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { unsupported event: $event } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList Action = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/fr.vsct.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"Tock Bot Framework"},{"location":"user-manual/dev/bot-framework/#le-framework-tock-en-kotlin","text":"Le Bot Framework Tock permet de d\u00e9velopper un bot en mode int\u00e9gr\u00e9, en utilisant un Domain Specifique Language (DSL) en Kotlin . Contrairement au mode Bot API encore en d\u00e9veloppement, le Bot Framework Kotlin permet d'exploiter toutes les possibilit\u00e9s de la plateforme Tock, notamment : Gestion des contextes utilisateurs Historique de conversation Notions avanc\u00e9es comme la fusion d'entit\u00e9s Etc. Exemple de fusion d'entit\u00e9s : lorsque un utilisateur demande \"demain\" dans une phrase (appelons cette entit\u00e9 date ) puis \"plut\u00f4t le soir\" dans une phrase suivante, la fusion permet de mettre \u00e0 jour automatiquement l'entit\u00e9 ( date ) avec les deux informations compl\u00e9mentaires : jour et cr\u00e9neau horaire dans cet exemple. Attention : dans ce mode de d\u00e9veloppement, contrairement au mode Bot API , il est n\u00e9cessaire que le module bot dispose d'une connexion \u00e0 la base de donn\u00e9e (MongoDB) de la plateforme Tock utilis\u00e9e. Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin .","title":"Le framework Tock en Kotlin"},{"location":"user-manual/dev/bot-framework/#demarrer-avec-le-framework","text":"","title":"D\u00e9marrer avec le framework"},{"location":"user-manual/dev/bot-framework/#documentation-kdoc","text":"La documentation du framework au format KDoc est disponible ici .","title":"Documentation KDoc"},{"location":"user-manual/dev/bot-framework/#dependance-bot-toolkit","text":"Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance bot-tookit \u00e0 l'application / au projet Kotlin. Par exemple dans un projet Maven : dependency groupId fr.vsct.tock /groupId artifactId bot-toolkit /artifactId version 19.3.2 /version /dependency Ou dans un projet Gradle : compile fr.vsct.tock:bot-toolkit:19.3.2","title":"D\u00e9pendance bot-toolkit"},{"location":"user-manual/dev/bot-framework/#un-bot-est-un-ensemble-de-parcours-stories","text":"Voici par exemple comment le Bot Open Data est d\u00e9fini : val openBot = bot ( bot_open_data , stories = listOf ( greetings , departures , arrivals , search ), hello = greetings ) Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de parcours ou stories . Une Story est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle, \u00e0 une ou plusieurs intentions dites \"secondaires\" (voir Concepts ). Ici le bot d\u00e9finit 4 parcours : greetings , departures , arrivals et search . Le parcours greetings est d\u00e9clar\u00e9 comme parcours principal, il sera pr\u00e9sent\u00e9 par d\u00e9faut au d\u00e9but d'une conversation : hello = greetings .","title":"Un bot est un ensemble de parcours (stories)"},{"location":"user-manual/dev/bot-framework/#une-story-simple","text":"Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e du parcours greetings : val greetings = story ( greetings ) { send ( Bienvenue chez le Bot Open Data Sncf! :) ) end ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) } Notez que dans le corps de la fonction, this est de type BotBus , \u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der \u00e0 tous les \u00e9lements contextuels disponibles. Concr\u00e8tement sela signifie que quand l'intention greetings sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock. Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est la derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un bus.end() . Voici maintenant la version compl\u00e8te de greetings : val greetings = story ( greetings ) { //cleanup state resetDialogState () send ( Bienvenue chez le Bot Open Data Sncf! :) ) send ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) withMessenger { buttonsTemplate ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , postbackButton ( Itin\u00e9raires , search ), postbackButton ( D\u00e9parts , Departures ), postbackButton ( Arriv\u00e9es , Arrivals ) ) } withGoogleAssistant { gaMessage ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , Itin\u00e9raires , D\u00e9parts , Arriv\u00e9es ) } end () } Deux notions ont \u00e9t\u00e9 ajout\u00e9es : resetDialogState() qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents) les m\u00e9thodes withMessenger{} et withGoogleAssistant{} qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur. Ici un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.","title":"Une Story simple"},{"location":"user-manual/dev/bot-framework/#demarrer-et-connecter-le-bot","text":"Pour d\u00e9marrer le bot, il suffit de rajouter dans votre main principal l'appel suivant : registerAndInstallBot ( openBot ) La variable openBot dans l'exemple est le bot que vous avez d\u00e9fini plus haut. Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s dans l'interface d'administration du bot, du menu Configuration Bot Configurations Create a new configuration . Pour en savoir plus sur les diff\u00e9rents connecteurs, voir cette page .","title":"D\u00e9marrer et connecter le bot"},{"location":"user-manual/dev/bot-framework/#aller-plus-loin","text":"Bien s\u00fbr, le StoryHandler de greetings ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame. Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.","title":"Aller plus loin"},{"location":"user-manual/dev/bot-framework/#intentions-secondaires","text":"Voici le d\u00e9but de la d\u00e9finition de la story search : val search = storyDef SearchDef ( search , otherStarterIntents = setOf ( indicate_origin ), secondaryIntents = setOf ( indicate_location )) { } Le parcours search d\u00e9finit une intention secondaire \"de d\u00e9marrage\" ( indicate_origin ) et une intention secondaire simple ( indicate_location ). Une intention secondaire \"de d\u00e9marrage\" est semblable en tout point \u00e0 une intention principale : d\u00e8s que cette intention est d\u00e9tect\u00e9e, le parcours search va \u00eatre ex\u00e9cut\u00e9, si la story courante ne poss\u00e8de pas cette intention en tant qu'intention secondaire. Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte est \"d\u00e9j\u00e0\" la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.","title":"Intentions secondaires"},{"location":"user-manual/dev/bot-framework/#manipuler-les-entites","text":"Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des extensions . Par exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 destination : val destinationEntity = openBot . entity ( location , destination ) var BotBus . destination : Place ? get () = place ( destinationEntity ) set ( value ) = setPlace ( destinationEntity , value ) private fun BotBus . place ( entity : Entity ): Place ? = entityValue ( entity , :: placeValue ) ?. place private fun BotBus . setPlace ( entity : Entity , place : Place ?) = changeEntityValue ( entity , place ?. let { PlaceValue ( place ) }) Une entit\u00e9 de type location et de role destination est cr\u00e9\u00e9e. Il s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP. Une variable destination est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier. Cette variable contient la valeur actuelle de la destination dans le contexte utilisateur. Voici une version compl\u00e9t\u00e9e de la story search qui utilise destination : val search = storyDef SearchDef ( search , setOf ( indicate_origin ), setOf ( indicate_location )) { //check mandatory entities when { destination == null - end ( Pour quelle destination? ) origin == null - end ( Pour quelle origine? ) departureDate == null - end ( Quand souhaitez-vous partir? ) } } Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0. Idem pour l'origine ou la date de d\u00e9part. Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ). La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante : val search = storyDef SearchDef ( search , setOf ( indicate_origin ), setOf ( indicate_location )) { //handle generic location intent if ( isIntent ( indicate_location ) location != null ) { if ( destination == null || origin != null ) { destination = returnsAndRemoveLocation () } else { origin = returnsAndRemoveLocation () } } //check mandatory entities when { destination == null - end ( Pour quelle destination? ) origin == null - end ( Pour quelle origine? ) departureDate == null - end ( Quand souhaitez-vous partir? ) } } Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination. Il est donc cod\u00e9 une r\u00e8gle simple : Si il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination. Sinon, il s'agit de l'origine.","title":"Manipuler les entit\u00e9s"},{"location":"user-manual/dev/bot-framework/#utiliser-handlerdef","text":"Dans la d\u00e9finition de la story search ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique SearchDef . Voici le code de cette classe : @GAHandler ( GASearchConnector :: class ) @MessengerHandler ( MessengerSearchConnector :: class ) class SearchDef ( bus : BotBus ) : HandlerDef SearchConnector ( bus ) { private val d : Place = bus . destination !! private val o : Place = bus . origin !! private val date : LocalDateTime = bus . departureDate !! override fun answer () { send ( De {0} \u00e0 {1} , o , d ) send ( D\u00e9part le {0} , date by datetimeFormat ) val journeys = SncfOpenDataClient . journey ( o , d , date ) if ( journeys . isEmpty ()) { end ( D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :( ) } else { send ( Voici la premi\u00e8re proposition : ) connector ?. sendFirstJourney ( journeys . first ()) end () } } } SearchDef \u00e9tend HandlerDef qui est un alias d'une classe du framework Tock. C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des parcours complexes. Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire : SearchConnector . SearchConnector est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations @GAHandler(GASearchConnector::class) et @MessengerHandler(MessengerSearchConnector::class) indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger). Que se passerait-il s'il n'y avait pas de connecteur pour Google Assistant par exemple ? La m\u00e9thode connector?.sendFirstJourney(journeys.first()) n'enverrait pas la r\u00e9ponse finale, puisque connector serait null .","title":"Utiliser HandlerDef"},{"location":"user-manual/dev/bot-framework/#utiliser-connectordef","text":"Voici maintenant une version simplifi\u00e9e de SearchConnector : sealed class SearchConnector ( context : SearchDef ) : ConnectorDef SearchDef ( context ) { fun Section . title (): CharSequence = i18n ( {0} - {1} , from , to ) fun sendFirstJourney ( journey : Journey ) = withMessage ( sendFirstJourney ( journey . publicTransportSections ())) abstract fun sendFirstJourney ( sections : List Section ): ConnectorMessage } Et voici son impl\u00e9mentation pour Messenger : class MessengerSearchConnector ( context : SearchDef ) : SearchConnector ( context ) { override fun sendFirstJourney ( sections : List Section ): ConnectorMessage = flexibleListTemplate ( sections . map { section - with ( section ) { listElement ( title (), content (), trainImage ) } }, compact ) } Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans SearchConnector et le comportement sp\u00e9cifique \u00e0 chaque connecteur se trouve dans les classes d\u00e9di\u00e9es.","title":"Utiliser ConnectorDef"},{"location":"user-manual/dev/bot-framework/#utiliser-storystep","text":"Parfois il est n\u00e9cessaire de se souvenir de l'\u00e9tape \u00e0 laquelle l'utilisateur se trouve dans la story courante. Pour cela Tock met \u00e0 disposition la notion de StoryStep . Il existe deux types de StoryStep :","title":"Utiliser StoryStep"},{"location":"user-manual/dev/bot-framework/#simplestorystep","text":"A utiliser dans les cas simples, pour lequels on va g\u00e9rer le comportement induit directement : enum class MyStep : SimpleStoryStep { a , b } val story = storyWithSteps MyStep ( intent ) { if ( step == a ) { // ... } else if ( step == b ) { // ... } else { //default case } } Pour modifier l'\u00e9tape courante, deux m\u00e9thodes sont disponibles : Modifier manuellement l'\u00e9tape val story = storyWithSteps MyStep ( intent ) { //(...) step = MyStep . a // l \u00e9tape sera persist\u00e9e tant que nous resterons dans cette story } Utiliser les boutons ou autres quick replies Plus de d\u00e9tails sur ce sujet plus bas .","title":"SimpleStoryStep"},{"location":"user-manual/dev/bot-framework/#les-storystep-avec-comportement","text":"Dans des cas plus complexes, on souhaite pouvoir d\u00e9finir un comportement pour chaque \u00e9tape. L'utilisation de HandlerDef est alors un pr\u00e9requis. enum class MySteps : StoryStep MyHandlerDef { //pas de comportement sp\u00e9cifique display , select { // la step select sera automatiquement s\u00e9lectionn\u00e9e si la sous-intention select est d\u00e9tect\u00e9e override val intent : IntentAware ? = SecondaryIntent . select //dans ce cas la r\u00e9ponse suivante sera apport\u00e9e override fun answer (): MyHandlerDef .() - Any ? = { end ( I don t know yet how to select something ) } }, disruption { //seule la r\u00e9ponse est configur\u00e9e override fun answer (): ScoreboardDef .() - Any ? = { end ( some perturbation ) } }; } Davantage d'options de configuration sont disponibles. Consultez la description de StoryStep .","title":"Les StoryStep avec comportement"},{"location":"user-manual/dev/bot-framework/#postback-buttons-quick-replies","text":"Messenger met \u00e0 disposition ce type de bouton, et la plupart des connecteurs avec interface graphique font de m\u00eame. Tock permet de d\u00e9finir l'action effectu\u00e9e suite \u00e0 un clic sur ces boutons. Dans l'exemple suivant, le bouton redirigera vers l'intention search . buttonsTemplate ( The bot is very limited! Only itineraries are supported :) , postbackButton ( Itineraries , search ) ) Il est possible de d\u00e9finir \u00e9galement une StoryStep et des param\u00e8tres d\u00e9di\u00e9s : //pour d\u00e9finir des param\u00e8tres, la pratique recommand\u00e9e est d \u00e9tendre l interface ParameterKey enum class ChoiceParameter : ParameterKey { nextResultDate , nextResultOrigin } buttonsTemplate ( The bot is very limited! Only itineraries are supported :) , postbackButton ( Itineraries , intent = search , //si aucune step n est indiqu\u00e9e, c est la step courante qui est utilis\u00e9e step = MyStep . a , parameters = //ce param\u00e8tre est stock\u00e9 sous forme de cha\u00eene de caract\u00e8re (les crochets sont utilis\u00e9s) nextResultDate [ nextDate ] + //ce param\u00e8tre est stock\u00e9 en json (les parenth\u00e8ses sont utilis\u00e9es) nextResultOrigin ( origin ) ) ) Pour r\u00e9cup\u00e9rer les param\u00e8tres du bouton sur lequel on a cliqu\u00e9 : val isClick = isChoiceAction () val nextDate = choice ( nextResultDate ) val nextOrigin : Locality = action . jsonChoice ( nextResultOrigin )","title":"Postback buttons &amp; quick replies"},{"location":"user-manual/dev/bot-framework/#tests-unitaires","text":"La page Tests Unitaires pr\u00e9sente le framework fourni pour r\u00e9aliser des TUs avec Tock.","title":"Tests Unitaires"},{"location":"user-manual/dev/bot-framework/#developper-son-propre-connecteur","text":"Il est possible de d\u00e9velopper son propre connecteur. Pour cela quatres \u00e9tapes sont n\u00e9cessaires : 1) Impl\u00e9menter l'interface Connector Voici un exemple d'impl\u00e9mentation : val testConnectorType = ConnectorType ( test ) class TestConnector ( val applicationId : String , val path : String ) : Connector { override val connectorType : ConnectorType = testConnectorType override fun register ( controller : ConnectorController ) { controller . registerServices ( path ) { router - //main API router . post ( $path/message ). blockingHandler { context - //ConnectorRequest est mon objet m\u00e9tier pass\u00e9 par l appli front val message : ConnectorRequest = mapper . readValue ( context . bodyAsString ) //transformation de l objet m\u00e9tier en Event tock val event = readUserMessage ( message ) // on passe l \u00e9v\u00e8nement au framework val callback = TestConnectorCallback ( applicationId , message . userId , context , controller ) controller . handle ( event , ConnectorData ( callback )) } } } override fun send ( event : Event , callback : ConnectorCallback , delayInMs : Long ) { callback as TestConnectorCallback if ( event is Action ) { //on enregistre l action callback . actions . add ( event ) //si c est la derni\u00e8re action \u00e0 envoyer, on envoie la r\u00e9ponse if ( event . metadata . lastAnswer ) { callback . sendAnswer () } } else { logger . trace { unsupported event: $event } } } } // pour r\u00e9cup\u00e9rer toutes les actions avant envoi class TestConnectorCallback ( override val applicationId : String , val userId : String , val context : RoutingContext , val controller : ConnectorController , val actions : MutableList Action = CopyOnWriteArrayList ()): ConnectorCallbackBase ( applicationId , testConnectorType ) { internal fun sendAnswer () { //on transforme la liste des r\u00e9ponses Tock en r\u00e9ponse m\u00e9tier val response = mapper . writeValueAsString ( actions . map {...}) //puis on envoie la r\u00e9ponse context . response (). end ( response ) } } 2) Impl\u00e9menter l'interface ConnectorProvider Voici un exemple d'impl\u00e9mentation : object TestConnectorProvider : ConnectorProvider { override val connectorType : ConnectorType = testConnectorType override fun connector ( connectorConfiguration : ConnectorConfiguration ): Connector { return TestConnector ( connectorConfiguration . connectorId , connectorConfiguration . path ) } } class TestConnectorProviderService : ConnectorProvider by TestConnectorProvider 3) Rendre disponible ce connecteur via un Service Loader : Pour cela, placez un fichier META-INF/services/fr.vsct.tock.bot.connector.ConnectorProvider dans le classpath, contenant le nom de la classe : mypackage.TestConnectorProviderService 4) Rajouter toutes les classes et fichiers cr\u00e9\u00e9s dans le classpath de l'admin et du bot. Le nouveau connecteur doit alors \u00eatre disponible dans l'interface Bot Configurations de Tock Studio .","title":"D\u00e9velopper son propre connecteur"},{"location":"user-manual/dev/developper/","text":"","title":"Developper"},{"location":"user-manual/dev/tester/","text":"Utiliser le framework de test Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : dependency groupId fr.vsct.tock /groupId artifactId bot-test /artifactId version 19.3.2 /version scope test /scope /dependency ou Gradle : testCompile fr.vsct.tock:bot-test:19.3.2 L'ensemble de ce framework est document\u00e9 au format KDoc ici . Ecrire un test simple L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , postbackButton ( Itin\u00e9raires , search ), postbackButton ( D\u00e9parts , Departures ), postbackButton ( Arriv\u00e9es , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) lastAnswer . assertMessage ( gaMessage ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , Itin\u00e9raires , D\u00e9parts , Arriv\u00e9es ) ) } Tester une Story sp\u00e9cifique Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( Pour quelle destination? ) } } Tester un dialogue Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( Je voudrais rechercher un itin\u00e9raire , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( Pour quelle destination? ) } ext . send ( Lille , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( Pour quelle origine? ) } ext . send ( Paris , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( Quand souhaitez-vous partir? ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( stop_area , 90 , Lille Europe , Lille Europe (Lille) , stop_area:OCE:SA:87223263 , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( Lille , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( Recherche , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( Quand souhaitez-vous partir? ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Utiliser le framework de test"},{"location":"user-manual/dev/tester/#utiliser-le-framework-de-test","text":"Tock met \u00e0 disposition des extensions pour tester le bot unitairement. Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie bot-test \u00e0 votre projet. Avec Maven : dependency groupId fr.vsct.tock /groupId artifactId bot-test /artifactId version 19.3.2 /version scope test /scope /dependency ou Gradle : testCompile fr.vsct.tock:bot-test:19.3.2 L'ensemble de ce framework est document\u00e9 au format KDoc ici .","title":"Utiliser le framework de test"},{"location":"user-manual/dev/tester/#ecrire-un-test-simple","text":"L'ensemble des exemples suivants utilisent JUnit5 . Une extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est disponible . @RegisterExtension @JvmField val ext = TockJUnit5Extension () Afin de tester la story greetings du bot Open Data, il suffit d'utiliser la m\u00e9thode ext.send() qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi : @Test fun `greetings story displays welcome message WHEN locale is fr` () { ext . send ( locale = Locale . FRENCH ) { firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) } } Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : lastAnswer . assertMessage ( buttonsTemplate ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , postbackButton ( Itin\u00e9raires , search ), postbackButton ( D\u00e9parts , Departures ), postbackButton ( Arriv\u00e9es , Arrivals ) ) ) Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur), il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester : ext . send ( connectorType = gaConnectorType , locale = Locale . FRENCH ) { firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) lastAnswer . assertMessage ( gaMessage ( Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , Itin\u00e9raires , D\u00e9parts , Arriv\u00e9es ) ) }","title":"Ecrire un test simple"},{"location":"user-manual/dev/tester/#tester-une-story-specifique","text":"Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings \u00e9tant la story par d\u00e9faut). Supposons que nous souhaitons la story search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante : @Test fun `search story asks for destination WHEN there is no destination in context` () { ext . send ( intent = search , locale = Locale . FRENCH ) { firstAnswer . assertText ( Pour quelle destination? ) } }","title":"Tester une Story sp\u00e9cifique"},{"location":"user-manual/dev/tester/#tester-un-dialogue","text":"Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine : @Test fun `search story asks for origin WHEN there is a destination but no origin in context` () { ext . send ( Je voudrais rechercher un itin\u00e9raire , search , locale = Locale . FRENCH ) { firstAnswer . assertText ( Pour quelle destination? ) } ext . send ( Lille , indicate_location , locationEntity setTo lille ) { firstBusAnswer . assertText ( Pour quelle origine? ) } ext . send ( Paris , indicate_location , locationEntity setTo paris ) { firstBusAnswer . assertText ( Quand souhaitez-vous partir? ) } } Le texte en premier param\u00e8tre de la m\u00e9thode send est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests. Les param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase. Par exemple : private val lille = PlaceValue ( SncfPlace ( stop_area , 90 , Lille Europe , Lille Europe (Lille) , stop_area:OCE:SA:87223263 , Coordinates ( 50.638861 , 3.075774 ) ) ) ext . send ( Lille , indicate_location , locationEntity setTo lille ) permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention indicate_location et avec une valeur pour l'entit\u00e9 location qui va \u00eatre la localisation lille Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire indicate_location afin d'indiquer l'origine : @Test fun `search story asks for departure date WHEN there is a destination and an origin but no departure date in context` () { ext . newRequest ( Recherche , search , locale = Locale . FRENCH ) { destination = lille origin = paris run () firstAnswer . assertText ( Quand souhaitez-vous partir? ) } } Les variables origin et destination sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction run() .","title":"Tester un dialogue"},{"location":"user-manual/studio/build-model/","text":"Construire les mod\u00e8les conversationnels La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus NLU et NLU QA pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Configuration , NLU et NLU QA . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au NLU , par exemple pour un usage comme l' Internet des objets . Rendez-vous dans la section NLU Le menu NLU renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot : Ajoutez et qualifiez des phrases Ajoutez une phrase Rendez-vous dans l'\u00e9cran Try it Saisissez une phrase Cr\u00e9ez une nouvelle intention Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent . Sp\u00e9cifiez des entit\u00e9s Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase. Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es. Validez la phrase Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate . Qualifiez d'autres phrases Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs. Parcourez les phrases du mod\u00e8le L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention. Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier : La s\u00e9lection du moteur NLU Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme). L'activation des mod\u00e8les d'entit\u00e9s Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. L'activation des sous-entit\u00e9s Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4. Valeurs pr\u00e9definies d'entit\u00e9s Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire Continuer... Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Construire les mod\u00e8les conversationnels"},{"location":"user-manual/studio/build-model/#construire-les-modeles-conversationnels","text":"La documentation Tock Studio peut \u00eatre parcourue \u00e9cran par \u00e9cran, notamment les menus NLU et NLU QA pour la gestion des mod\u00e8les conversationnels. N'h\u00e9sitez pas \u00e0 vous y r\u00e9f\u00e9rer si vous avez une question sur un onglet / une option en particulier. Cette page pr\u00e9sente la construction des mod\u00e8les en se focalisant plus sur l'usage et l'apprentissage, s'autorisant \u00e0 passer d'un \u00e9cran \u00e0 un autre sans d\u00e9tailler exhaustivement chaque fonctionnalit\u00e9 de la plateforme. Notez qu'il est possible de d\u00e9ployer la plateforme Tock NLU seule, dans ce cas les interfaces graphiques Tock se limitent aux menus Configuration , NLU et NLU QA . Cette page peut donc servir de tutoriel pour une utilisation de Tock restreinte au NLU , par exemple pour un usage comme l' Internet des objets .","title":"Construire les mod\u00e8les conversationnels"},{"location":"user-manual/studio/build-model/#rendez-vous-dans-la-section-nlu","text":"Le menu NLU renvoie sur l'onglet Inbox par d\u00e9faut. Au d\u00e9part vous n'avez pas de phrases si personne n'a encore parl\u00e9 au bot :","title":"Rendez-vous dans la section NLU"},{"location":"user-manual/studio/build-model/#ajoutez-et-qualifiez-des-phrases","text":"","title":"Ajoutez et qualifiez des phrases"},{"location":"user-manual/studio/build-model/#ajoutez-une-phrase","text":"Rendez-vous dans l'\u00e9cran Try it Saisissez une phrase","title":"Ajoutez une phrase"},{"location":"user-manual/studio/build-model/#creez-une-nouvelle-intention","text":"Attribuez \u00e0 la phrase une nouvelle intention en s\u00e9lectionnant Create a New Intent dans la liste de s\u00e9lection Intent .","title":"Cr\u00e9ez une nouvelle intention"},{"location":"user-manual/studio/build-model/#specifiez-des-entites","text":"Selon ce \u00e0 quoi est destin\u00e9e l'intention, vous pouvez sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse dans la phrase : S\u00e9lectionnez une portion de phrase correspondant \u00e0 l'entit\u00e9 (ie. un groupe de mots \u00e0 s\u00e9lectionner avec la souris) Cliquez sur Add New Entity qui vient d'appara\u00eetre Choisissez un type d'entit\u00e9 existant ou cr\u00e9ez-en un nouveau Donnez un r\u00f4le \u00e0 cette entit\u00e9 Exemple : dans la phrase \"je veux aller de Paris \u00e0 New York\", probablement que Paris et New York sont deux entit\u00e9s du m\u00eame type (localit\u00e9) mais n'ont pas le m\u00eame r\u00f4le dans l'intention (origine et destination). Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.","title":"Sp\u00e9cifiez des entit\u00e9s"},{"location":"user-manual/studio/build-model/#tirez-parti-des-entites-predefinies","text":"Par d\u00e9faut, Tock propose un certain nombre de types d' entit\u00e9s pr\u00e9d\u00e9finies , notamment les types support\u00e9s par la biblioth\u00e8que Duckling : montants, dates, etc. Si vous s\u00e9lectionnez ces types d'entit\u00e9s, celles-ci seront automatiquement reconnues et valoris\u00e9es.","title":"Tirez parti des entit\u00e9s pr\u00e9d\u00e9finies"},{"location":"user-manual/studio/build-model/#validez-la-phrase","text":"Lorsque l'intention et les entit\u00e9s sont correctes, terminez la qualification de la phrase en cliquant sur Validate .","title":"Validez la phrase"},{"location":"user-manual/studio/build-model/#qualifiez-dautres-phrases","text":"Apr\u00e8s deux ou trois phrases pour une intention donn\u00e9e, il est courant que le mod\u00e8le commence \u00e0 reconna\u00eetre les phrases suivantes et d\u00e9tectent bien l'intention (avec un score grandissant, du moment que les phrases sont relativement proches / en rapport avec l'intention bien s\u00fbr) : Si une phrase n'est pas bien qualifi\u00e9e, changez l'intention / les entit\u00e9s puis faites Validate pour appliquer la correction. Si la phrase \u00e9tait bien qualifi\u00e9e, faites directement Validate . Dans les deux cas, vous alimentez ainsi le mod\u00e8le, qui se reconstruit, et devient plus pertinent pour les pharses suivantes. Vous \u00eates en train de construire votre mod\u00e8le conversationnel ! C'est le d\u00e9but de l' apprentissage pour votre bot ou votre application conversationnelle. La qualification de phrases, leur nombre mais aussi leur vari\u00e9t\u00e9 (notamment dans le temps, car les utilisateurs d'aujourd'hui ne sont pas exactement les utilisateurs de demain) sont la base d'un mod\u00e8le pertinent et d'une bonne exp\u00e9rience conversationnelle pour les utilisateurs.","title":"Qualifiez d'autres phrases"},{"location":"user-manual/studio/build-model/#parcourez-les-phrases-du-modele","text":"L'onglet Search permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res. Le plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res. Chaque phrase \u00e0 un \u00e9tat Status qui peut \u00e9voluer au cours du temps : Inbox : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le Validated : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante) Included in model : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP Cet \u00e9cran permet donc de consulter les phrases faisant d\u00e9j\u00e0 partie du mod\u00e8le (autrement dit d\u00e9j\u00e0 qualifi\u00e9s), et de faire \u00e9voluer les qualifications de phrases au cours du temps. Il est notamment possible de re-qualifier tout un groupe de phrases. Par exemple, vous pourrez cr\u00e9er une nouvelle intention plus tard et d\u00e9cider que toutes les phrases remplissant un certain crit\u00e8re (mot-clef ou autre) devront dor\u00e9navant \u00eatre qualifi\u00e9es dans cette nouvelle intention.","title":"Parcourez les phrases du mod\u00e8le"},{"location":"user-manual/studio/build-model/#modifiez-les-caracteristiques-avancees-de-lapplication","text":"Le menu Applications donne acc\u00e8s \u00e0 la liste des applications/bots disponibles sur la plateforme : Avec le bouton de modification, plusieurs options sont disponibles, en particulier :","title":"Modifiez les caract\u00e9ristiques avanc\u00e9es de l'application"},{"location":"user-manual/studio/build-model/#la-selection-du-moteur-nlu","text":"Vous avez la possibilit\u00e9 de s\u00e9lectionner la biblioth\u00e8que NLU utilis\u00e9e par ce bot (\u00e0 condition que plusieurs moteurs soient pr\u00e9sents dans l'installation de la plateforme).","title":"La s\u00e9lection du moteur NLU"},{"location":"user-manual/studio/build-model/#lactivation-des-modeles-dentites","text":"Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. Par exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 duckling:datetime , les dates seront automatiquement reconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention. En interne, un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le. Cette option est activ\u00e9e par d\u00e9faut. Il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels la d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s.","title":"L'activation des mod\u00e8les d'entit\u00e9s"},{"location":"user-manual/studio/build-model/#lactivation-des-sous-entites","text":"Si vous activez cette option, vous pourrez qualifier plusieurs niveaux d'entit\u00e9s : Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.","title":"L'activation des sous-entit\u00e9s"},{"location":"user-manual/studio/build-model/#valeurs-predefinies-dentites","text":"Une entit\u00e9 donn\u00e9e peut avoir des valeurs pr\u00e9d\u00e9finies . Pour cela vous devez aller dans l'onglet Entities , selectionnez une entit\u00e9. L'ic\u00f4ne \u00e0 cot\u00e9 de l'ic\u00f4ne de suppression montre les types d'entit\u00e9s que vous pouvez modifier : Dans l'exemple ci-dessus, deux labels sont d\u00e9finis pour la valeur de semaine : Semaine hebdomadaire","title":"Valeurs pr\u00e9definies d'entit\u00e9s"},{"location":"user-manual/studio/build-model/#continuer","text":"Pour en savoir plus sur la gestion des entit\u00e9s, notamment dans des intentions cr\u00e9\u00e9es programmatiquement, out tout simplement pour continuer de parcourir le manuel utilisateur Tock, vous pouvez vous rendre dans le chapitre D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/build/","text":"Le menu Build Le menu Build permet de construire des parcours et des r\u00e9ponses aux phrases utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet i18n . L'onglet New Story Cr\u00e9er une r\u00e9ponse simple Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours. Cr\u00e9er des r\u00e9ponses complexes Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action. Entit\u00e9s obligatoires Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\". Actions Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision. L'onglet Search Stories Cette \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories . L'onglet Bot Flow Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des intentions : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot Flot des conversations : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs TODO : \u00e0 d\u00e9tailler L'onglet i18n Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet i18n mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me. L'onglet Feature Flipping Cet section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface ( Feature Flipping ). TODO : \u00e0 d\u00e9tailler. Continuer... Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Build_"},{"location":"user-manual/studio/build/#le-menu-build","text":"Le menu Build permet de construire des parcours et des r\u00e9ponses aux phrases utilisateur. Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Cr\u00e9er son premier bot avec Tock Studio pour un exemple de cr\u00e9ation de parcours ou Construire un bot multilingue pour l'utilisation de l'onglet i18n .","title":"Le menu Build"},{"location":"user-manual/studio/build/#longlet-new-story","text":"","title":"L'onglet New Story"},{"location":"user-manual/studio/build/#creer-une-reponse-simple","text":"Le guide Cr\u00e9er son premier bot avec Tock Studio pr\u00e9sente un exemple de cr\u00e9ation de parcours avec une r\u00e9ponse simple via New Story . L'onglet Test Test the bot permet ensuite de rapidement v\u00e9rifier le comportement du bot sur ce parcours.","title":"Cr\u00e9er une r\u00e9ponse simple"},{"location":"user-manual/studio/build/#creer-des-reponses-complexes","text":"Il est possible d'indiquer plusieurs r\u00e9ponses et \u00e9galement des r\u00e9ponses \"riches\" appel\u00e9es Media Message . Cela permet, quel que soit le canal d'afficher des images, des titres, des sous-titres et des boutons d'action.","title":"Cr\u00e9er des r\u00e9ponses complexes"},{"location":"user-manual/studio/build/#entites-obligatoires","text":"Il est possible, avant d'afficher la r\u00e9ponse principale, de v\u00e9rifier si certaines entit\u00e9es sont renseign\u00e9es, et si ce n'est pas le cas, d'afficher la question ad\u00e9quate. L'option correspondante est appell\u00e9e Mandatory Entities . Par exemple, supposons que nous ayons besoin de conna\u00eetre la destination de l'utilisateur. Si il ne l'a pas d\u00e9j\u00e0 indiqu\u00e9e, le bot devrait lui demander \"Pour quelle destination ?\".","title":"Entit\u00e9s obligatoires"},{"location":"user-manual/studio/build/#actions","text":"Les actions sont pr\u00e9sent\u00e9es comme des suggestions, quand le canal le permet. Il est possible de pr\u00e9senter une arborescence d'actions pour construire un arbre de d\u00e9cision.","title":"Actions"},{"location":"user-manual/studio/build/#longlet-search-stories","text":"Cette \u00e9cran permet de parcourir et g\u00e9rer les parcours ou stories cr\u00e9\u00e9es. Il peut s'agir des parcours configur\u00e9s via Tock Studio (ie. avec l'onglet New Story ) mais aussi les parcours d\u00e9clar\u00e9s programmatiquement via Bot API . Pour voir ces derniers, d\u00e9cochez l'option Only Configured Stories .","title":"L'onglet Search Stories"},{"location":"user-manual/studio/build/#longlet-bot-flow","text":"Cet \u00e9cran permet d'analyser le flot des intentions et des conversations : Flot des intentions : analyse statique des parcours et arbres de d\u00e9cisions propos\u00e9s par le bot Flot des conversations : analyse dynamique des parcours r\u00e9ellement effectu\u00e9s par les utilisateurs TODO : \u00e0 d\u00e9tailler","title":"L'onglet Bot Flow"},{"location":"user-manual/studio/build/#longlet-i18n","text":"Cet onglet permet de modifier les r\u00e9ponses du bot, dynamiquement selon plusieurs crit\u00e8res possibles : La langue (c'est ce qu'on appelle internationalisation ou i18n ) Le canal (textuel ou vocal), c'est-\u00e0-dire en pratique le connecteur Selon un roulement : il est possible d'enregistrer plusieurs textes de r\u00e9ponse pour un m\u00eame label dans une m\u00eame langue sur un m\u00eame connecteur - le bot r\u00e9pondra alors al\u00e9atoirement l'un de ces textes, puis effectuera un roulement afin de ne pas toujours r\u00e9pondre la m\u00eame chose. Cela permet de rendre le bot plus agr\u00e9able en variant ses r\u00e9ponses. Voir aussi Construire un bot multilingue pour l'utilisation de l'onglet i18n mais aussi les aspects d\u00e9veloppement sur ce th\u00e8me.","title":"L'onglet i18n"},{"location":"user-manual/studio/build/#longlet-feature-flipping","text":"Cet section permet de g\u00e9rer des fonctions activables ou d\u00e9sactivables via l'interface ( Feature Flipping ). TODO : \u00e0 d\u00e9tailler.","title":"L'onglet Feature Flipping"},{"location":"user-manual/studio/build/#continuer","text":"Rendez-vous dans Menu Test pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/configuration/","text":"Le menu Configuration Le menu Configuration permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc. L'onglet NLU Applications Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications. Cr\u00e9er une application Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir D\u00e9ployer une plateforme pour en savoir plus) Modifier, importer et exporter une application Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle L'onglet Bot Configurations Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement. Se connecter programmatiquement au bot Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API . G\u00e9rer les connecteurs La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs . Connecteurs de test Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ). Continuer... Rendez-vous dans Menu NLU pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Configuration_"},{"location":"user-manual/studio/configuration/#le-menu-configuration","text":"Le menu Configuration permet de cr\u00e9er et param\u00e9trer les applications conversationnelles Tock (c'est-\u00e0-dire les mod\u00e8les / bots pouvant co-exister sur une plateforme). Plusieurs fonctions d'administration et de configuration des bots sont \u00e9galement disponibles via ce menu : importer/exporter une configuration, param\u00e9trer la langue, les connecteurs, etc.","title":"Le menu Configuration"},{"location":"user-manual/studio/configuration/#longlet-nlu-applications","text":"Cet \u00e9cran permet de cr\u00e9er, modifier, supprimer des applications conversationnelles Tock. Lors de la premi\u00e8re connexion \u00e0 la plateforme de d\u00e9monstration , un assistant simplifi\u00e9 permet de cr\u00e9er la premi\u00e8re application (le premier bot). Par la suite, vous pouvez passer par cet \u00e9cran pour ajouter d'autres applications.","title":"L'onglet NLU Applications"},{"location":"user-manual/studio/configuration/#creer-une-application","text":"Pour ajouter une application, cliquez sur Create New Application : Saisissez un nom / identifiant pour l'application Choisissez si le mod\u00e8le pourra inclure des entit\u00e9s voire des sous-entit\u00e9s (cf Concepts pour en savoir plus) S\u00e9lectionnez une ou plusieurs langues (voir Construire un bot multilingue pour en savoir plus) S\u00e9lectionnez un moteur NLU ( Apache OpenNLP ou Stanford CoreNLP , voir D\u00e9ployer une plateforme pour en savoir plus)","title":"Cr\u00e9er une application"},{"location":"user-manual/studio/configuration/#modifier-importer-et-exporter-une-application","text":"Pour chaque application d\u00e9j\u00e0 cr\u00e9\u00e9e, vous pouvez par la suite : Download an application dump : t\u00e9l\u00e9charger sa configuration au format JSON : langue, mod\u00e8le intentions/entit\u00e9s, etc. Download a sentences dump : t\u00e9l\u00e9charger ses phrases qualifi\u00e9es au format JSON Edit : modifier la configuration de l'application Un formulaire permet de modifier la configuraion initiale Une section Advanced options ajoute d'autres param\u00e8tres pour les utilisateurs avertis : Upload dump : charger une configuration ou des phrases qualifi\u00e9es \u00e0 partir d'un fichier au format JSON. Seules les nouvelles intentions/phrases seront ajout\u00e9es, cette fonction ne modifie pas / ne supprime pas les intentions/phrases existantes Trigger build : d\u00e9clencher/forcer la reconstruction du mod\u00e8le NLU Engine configuration : param\u00e9trer finement le moteur NLU sous-jacent (les param\u00e8tres d\u00e9pendant du moteur utilis\u00e9, Apache OpenNLP ou Stanford CoreNLP ) Alexa Export : exporter le mod\u00e8le Tock dans un format utilisable par Alexa La fonction Upload dump (voir ci-dessus) est \u00e9galement accessible directement en bas d'\u00e9cran, permettant : Soit de modifier une application (si l' application name existe) Soit d'en cr\u00e9er/importer une nouvelle","title":"Modifier, importer et exporter une application"},{"location":"user-manual/studio/configuration/#longlet-bot-configurations","text":"Cet \u00e9cran permet d'acc\u00e9der aux connecteurs d'un bot, d'en ajouter, modifier ou supprimer. C'est aussi l\u00e0 que vous trouvez les informations pour se connecter programmatiquement.","title":"L'onglet Bot Configurations"},{"location":"user-manual/studio/configuration/#se-connecter-programmatiquement-au-bot","text":"Le param\u00e9trage pour se connecter au bot programmatiquement (ie. via un programme / langage de programmation) se trouve dans cet \u00e9cran : L' API Key peut \u00eatre copi\u00e9e et embarqu\u00e9e dans le code client de la Bot API pour connecter des parcours programm\u00e9s en Kotlin ou dans un autre langage de programmation Une adresse / URL peut \u00eatre configur\u00e9e pour utiliser le mode WebHook de Bot API Pour en savoir plus sur ces param\u00e8tres et le d\u00e9veloppement de parcours, voir Bot API .","title":"Se connecter programmatiquement au bot"},{"location":"user-manual/studio/configuration/#gerer-les-connecteurs","text":"La liste des connecteurs du bot est affich\u00e9e sous la clef d'API. Pour ajouter un connecteur au bot, cliquez sur Create a new Configuration . Tous les connecteurs poss\u00e8dent la configuration suivante : Configuration name : le nom/identifiant du bot Connector type : le type de canal (par exemple Messenger, Slack, etc.) Connector identifier : un identifiant pour le connecteur, unique pour le bot Relative REST path : un chemin relatif unique pour la plateforme, pour communiquer avec le bot sur ce canal. Par d\u00e9faut, le chemin est de la forme /io/{organisation}/{application}/{canal} ce qui le rend unique sur la plateforme (\u00e0 moins que deux connecteurs du m\u00eame type soient d\u00e9clar\u00e9s pour le m\u00eame bot). Chaque connecteur poss\u00e8de \u00e9galement une configuration suppl\u00e9mentaire sp\u00e9cifique \u00e0 ce type de connecteur. Ces param\u00e8tres sont dans Connector Custom Configuration . Ces param\u00e8tres sp\u00e9cifiques sont document\u00e9s avec chaque type de connecteur/canal, voir Les connecteurs .","title":"G\u00e9rer les connecteurs"},{"location":"user-manual/studio/configuration/#connecteurs-de-test","text":"Pour chaque connecteur ajout\u00e9 au bot, un connecteur de test est aussi cr\u00e9\u00e9 et configur\u00e9. Il sert \u00e0 \"simuler\" le connecteur lorsqu'on teste le bot directement dans l'interface Tock Studio (menu Test Test the bot ). Par d\u00e9faut, les connecteurs de test ne sont pas affich\u00e9s dans l'\u00e9cran Bot Configurations . Cliquez sur Display test configurations pour les voir et \u00e9ventuellement les modifier. En particulier, si vous obtenez des messages d'erreur de connexion dans la page Test the bot , n'h\u00e9sitez pas \u00e0 v\u00e9rfier la configuration de test notamment l'adresse Application base url (pour une plateforme d\u00e9ploy\u00e9e avec Docker Compose par d\u00e9faut, ce devrait \u00eatre http://bot_api:8080 avec le nom du conteneur et le port d\u00e9clar\u00e9s dans le descripteur docker-compose-bot.yml ).","title":"Connecteurs de test"},{"location":"user-manual/studio/configuration/#continuer","text":"Rendez-vous dans Menu NLU pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/general/","text":"L'interface Tock Studio Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s. Connexion \u00e0 l'application Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte github. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte github est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part. Le bandeau applicatif En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter Continuer... Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"L'interface _Tock Studio_"},{"location":"user-manual/studio/general/#linterface-tock-studio","text":"Cette page pr\u00e9sente les caract\u00e9ristiques g\u00e9n\u00e9rales de Tock Studio . Les pages suivantes couvrent les diff\u00e9rents menus de l'application et diff\u00e9rentes fonctionnalit\u00e9s.","title":"L'interface Tock Studio"},{"location":"user-manual/studio/general/#connexion-a-lapplication","text":"Un navigateur standard suffit pour acc\u00e9der \u00e0 Tock Studio . L'utilisateur est invit\u00e9 \u00e0 s'authentifier : Sur la plateforme Tock de d\u00e9monstration , l'utilisateur est invit\u00e9 \u00e0 s'authentifier via son compte github. Celui-ci doit alors accepter que Tock acc\u00e8de \u00e0 son compte - seul l'identifiant du compte github est lu par Tock. Sur une plateforme Tock par d\u00e9faut, les identifiants sont admin@app.com / password . Les identifiants par d\u00e9faut sont d\u00e9finis dans fichier source bot/admin/web/src/environments/environment.ts et il est recommand\u00e9 de les modifier. Il est aussi possible, en alternative, d'utiliser un m\u00e9canisme d'authentification en amont de l'application, par exemple via un service Apache HTTPd ou un service cloud comme AWS Cognito d'une part et un annuaire type LDAP d'autre part.","title":"Connexion \u00e0 l'application"},{"location":"user-manual/studio/general/#le-bandeau-applicatif","text":"En haut \u00e0 gauche de l'interface se trouvent : Un bouton permettant d'afficher (ou de masquer) les diff\u00e9rents menus Tock Studio Le nom de l'interface En haut \u00e0 droite de l'interface se trouvent : L'application / le bot couramment s\u00e9lectionn\u00e9 (utile lorsque plusieurs bots co-existent sur la plateforme) La langue couramment s\u00e9lectionn\u00e9e (utile pour tester un bot multilingue) Un lien pour se d\u00e9connecter","title":"Le bandeau applicatif"},{"location":"user-manual/studio/general/#continuer","text":"Rendez-vous dans Menu Configuration pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/monitoring/","text":"Le menu Monitoring Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations. L'onglet Users Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur. L'onglet Dialogs A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc. Continuer... Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Monitoring_"},{"location":"user-manual/studio/monitoring/#le-menu-monitoring","text":"Le menu Monitoring permet de suivre et observer les utilisateurs connect\u00e9s ainsi que les conversations.","title":"Le menu Monitoring"},{"location":"user-manual/studio/monitoring/#longlet-users","text":"Cet onglet vous permet de voir les derniers utilisateurs connect\u00e9s au bot : Nombre d'utilisateurs connect\u00e9s Date du dernier \u00e9change avec un utilisateur Dernier message envoy\u00e9 Etc. En cliquant sur Display dialog , vous pouvez voir la conversation de cet utilisateur.","title":"L'onglet Users"},{"location":"user-manual/studio/monitoring/#longlet-dialogs","text":"A l'instar de la vue Users , cette \u00e9cran permet d'observer les derni\u00e8res conversations. Il est possible de les filtrer par connecteur, intention, etc.","title":"L'onglet Dialogs"},{"location":"user-manual/studio/monitoring/#continuer","text":"Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/nlu-qa/","text":"Le menu NLU QA Le menu NLU QA permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels. L'onglet Stats Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration ) L'onglet Intent distance TODO L'onglet Model Builds Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le. L'onglet Tests Trend Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ). L'onglet Intent Test Errors Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. L'onglet Entity Test Errors A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le. Continuer... Rendez-vous dans Menu Build pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _NLU QA_"},{"location":"user-manual/studio/nlu-qa/#le-menu-nlu-qa","text":"Le menu NLU QA permet d'\u00e9valuer et de suivre dans le temps la qualit\u00e9/pertinence/performance des mod\u00e8les conversationnels.","title":"Le menu NLU QA"},{"location":"user-manual/studio/nlu-qa/#longlet-stats","text":"Cet \u00e9cran pr\u00e9sente des graphes pour suivre l'\u00e9volution de plusieurs indicateurs de la qualit\u00e9 du mod\u00e8le conversationnel : Pertinence : les scores des algorithmes de d\u00e9tection sur les intentions ( Intent average probability ) et sur les entit\u00e9s ( Entity average probability ) Trafic / erreurs : le nombre de sollicitations du mod\u00e8le ( Calls ) et le nombre d'erreurs ( Errors ) Performance : le temps de r\u00e9ponse du mod\u00e8le ( Average call duration )","title":"L'onglet Stats"},{"location":"user-manual/studio/nlu-qa/#longlet-intent-distance","text":"TODO","title":"L'onglet Intent distance"},{"location":"user-manual/studio/nlu-qa/#longlet-model-builds","text":"Cet \u00e9cran pr\u00e9sente des statistiques sur les derni\u00e8res reconstructions du mod\u00e8le. Il s'agit donc d'indications sur la performance du mod\u00e8le.","title":"L'onglet Model Builds"},{"location":"user-manual/studio/nlu-qa/#longlet-tests-trend","text":"Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification, ou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles. Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire un mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le. Le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois pour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel. Pr\u00e9cision que ces tests ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents. Cet onglet donne l'\u00e9volution de la pertinence des tests partiels de mod\u00e8le. Par d\u00e9faut, les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes. Il est possible de configurer ce comportement avec la propri\u00e9t\u00e9 tock_test_model_timeframe (par d\u00e9faut : 0,5 ).","title":"L'onglet Tests Trend"},{"location":"user-manual/studio/nlu-qa/#longlet-intent-test-errors","text":"Cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection d'intentions (voir ci-dessus), avec le d\u00e9tails des phrases/expressions reconnues diff\u00e9remment du mod\u00e8le r\u00e9el. Dans cet exemple, aucune \"vraie\" erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. On peut toutefois constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement, avec une probabilit\u00e9 \u00e9lev\u00e9e. Pour chaque phrase il est possible via la colonne Actions de confirmer que le mod\u00e8le de base est correct (avec Validate Intent ) ou de corriger l'erreur d\u00e9tect\u00e9e ( Change The Intent ). Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Intent Test Errors"},{"location":"user-manual/studio/nlu-qa/#longlet-entity-test-errors","text":"A l'instar de Intent Test Errors pour les entit\u00e9s, cet \u00e9cran pr\u00e9sente les r\u00e9sultats des tests partiels de d\u00e9tection des entit\u00e9s. Il est int\u00e9ressant d'analyser p\u00e9riodiquement ces \u00e9carts, certaines diff\u00e9rences s'expliquant bien, \u00e9tant m\u00eame parfois \"assum\u00e9es\" (faux n\u00e9gatifs), d'autres pouvant r\u00e9veler un probl\u00e8me dans le mod\u00e8le.","title":"L'onglet Entity Test Errors"},{"location":"user-manual/studio/nlu-qa/#continuer","text":"Rendez-vous dans Menu Build pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/nlu/","text":"Le menu NLU Le menu NLU (Natural Language Understanding) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage. L'onglet Try it Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase. L'onglet Inbox Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus). L'onglet Unknown Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ). L'onglet Search Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le. L'onglet Intents Cet \u00e9cran permet de g\u00e9rer les intentions. L'onglet Entities Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es. L'onglet Logs Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue). Continuer... Rendez-vous dans Menu NLU QA pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _NLU_"},{"location":"user-manual/studio/nlu/#le-menu-nlu","text":"Le menu NLU (Natural Language Understanding) permet de cr\u00e9er, modifier, enrichir les mod\u00e8les conversationnels : d\u00e9clarer des intentions et des entit\u00e9s , qualifier des phrases, etc. (voir Concepts pour en savoir plus). Dans cette page, le d\u00e9tail de chaque onglet est pr\u00e9sent\u00e9. Voir aussi Construire les mod\u00e8les conversationnels pour une pr\u00e9sentation plus guid\u00e9e par l'usage.","title":"Le menu NLU"},{"location":"user-manual/studio/nlu/#longlet-try-it","text":"Cet \u00e9cran permet d'entrer des phrases et et de v\u00e9rifier quelle intention/entit\u00e9s sont d\u00e9tect\u00e9es. Saisissez une phrase et validez pour voir la d\u00e9tection r\u00e9sultant du mod\u00e8le conversationnel (en pratique : comment le bot interpr\u00e8te la phrase). S'affichent alors : Intent : l'intention reconnue Language : la langue d\u00e9tect\u00e9e Le(s) score(s) retourn\u00e9(s) par les algorithmes (selon leur niveau de confiance sur l'intention et sur les \u00e9ventuelles entit\u00e9s) Le cas \u00e9ch\u00e9ant, chaque entit\u00e9 d\u00e9tect\u00e9e avec son r\u00f4le/type et son score Il est possible de modifier tous les \u00e9l\u00e9ments d\u00e9tect\u00e9s depuis cet \u00e9cran : Pour modifier l'intention (voire en cr\u00e9er une nouvelle \u00e0 la vol\u00e9e) ou la langue d\u00e9tect\u00e9es, utilisez les champs / listes de s\u00e9lection sous la phrase Pour supprimer une entit\u00e9, utilisez le bouton \u00e0 c\u00f4t\u00e9 du score de l'entit\u00e9 Pour ajouter une entit\u00e9, s\u00e9lectionnez avec la souris un bloc de mots dansla phrase puis pr\u00e9cisez son r\u00f4le/type. Remarque : si vous avez activ\u00e9 cette option au niveau de l'application/bot, il est possible de d\u00e9clarer des sous-entit\u00e9s . Vous en apprendrez plus dans Construire les mod\u00e8les conversationnels . Les boutons et commandes suivantes sont disponibles pour la phrase dans sa globalit\u00e9 : Delete : supprime la phrase Unknown : qualifier la phrase en intention inconnue (r\u00e9ponse par d\u00e9faut) Validate : confirmer l'intention/entit\u00e9s d\u00e9tect\u00e9es et enregistrer la phrase dans le mod\u00e8le (provoquant in fine une reconstruction du mod\u00e8le, son corpus \u00e9tant enrichi de cette phrase) D'autres liens sont accessibles pour afficher les conversations contenant cette phrase, copier le contenu de la phrase, cr\u00e9er un parcours \u00e0 partir de cette phrase.","title":"L'onglet Try it"},{"location":"user-manual/studio/nlu/#longlet-inbox","text":"Cet onglet montre (avec de la pagination et quelques options d'affichage) l'ensemble des phrases re\u00e7ues par le mod\u00e8le NLU avec les intentions/entit\u00e9s/langue/scores d\u00e9tect\u00e9s. Ces phrases peuvent provenir de v\u00e9ritables utilisateurs quelques soient les canaux, d'une saisie dans l'onglet Try it ou encore d'une conversation via la page Test the bot dans Tock Studio . Lorsque vous faites des tests depuis un canal externe, n'h\u00e9sitez pas \u00e0 cliquer sur le bouton Refresh (en haut \u00e0 gauche de l'\u00e9cran) pour rafra\u00eechir la liste des phrases. Les boutons et commandes sous chaque phrase sont identiques \u00e0 ceux de l'onglet Try it (voir ci-dessus).","title":"L'onglet Inbox"},{"location":"user-manual/studio/nlu/#longlet-unknown","text":"Cet \u00e9cran permet de parcourir les phrases dont l'intention n'a pas \u00e9t\u00e9 reconnue (intention unknown ).","title":"L'onglet Unknown"},{"location":"user-manual/studio/nlu/#longlet-search","text":"Cet \u00e9cran permet de faire des recherches dans l'ensemble des phrases : Inbox mais aussi phrases qualifi\u00e9es enregistr\u00e9es dans le mod\u00e8le.","title":"L'onglet Search"},{"location":"user-manual/studio/nlu/#longlet-intents","text":"Cet \u00e9cran permet de g\u00e9rer les intentions.","title":"L'onglet Intents"},{"location":"user-manual/studio/nlu/#longlet-entities","text":"Cet \u00e9cran permet de g\u00e9rer les entit\u00e9s, notamment les notions d'entit\u00e9s partag\u00e9es.","title":"L'onglet Entities"},{"location":"user-manual/studio/nlu/#longlet-logs","text":"Cet \u00e9cran pr\u00e9sente le journal complet des phrases re\u00e7ues et permet de remonter aux conversations (ie. l'ensemble des phrases re\u00e7ues et r\u00e9ponses du bot pour un utilisateur). Remarque : contrairement \u00e0 la vue Inbox , les Logs montrent les phrases re\u00e7ues m\u00eame lorsqu'elles existent d\u00e9j\u00e0 \u00e0 l'identique dans le mod\u00e8le (dans ce cas, le mod\u00e8le et les algorithmes ne sont m\u00eame pas interrog\u00e9s, la r\u00e9ponse \u00e9tant connue).","title":"L'onglet Logs"},{"location":"user-manual/studio/nlu/#continuer","text":"Rendez-vous dans Menu NLU QA pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."},{"location":"user-manual/studio/test/","text":"Le menu Test Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques. L'onglet Test the bot Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue github . Pour parler \u00e0 un bot dans l'interface, une fois dans Test Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc. L'onglet Test Plans TODO Continuer... Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Le menu _Test_"},{"location":"user-manual/studio/test/#le-menu-test","text":"Le menu Test permet de tester un bot directement dans l'interface Tock Studio , ainsi que de g\u00e9rer des plans de tests automatiques.","title":"Le menu Test"},{"location":"user-manual/studio/test/#longlet-test-the-bot","text":"Via ce menu, vous pouvez parler directement au bot en simulant diff\u00e9rentes langues et connecteurs. Cela permet de tester rapidement et simplement un bot dans l'interface Tock Studio , sans avoir \u00e0 utiliser de logiciels et canaux externes. L'interface reste minimale car l'objectif est de tester rapidement le bot, pas d'obtenir une v\u00e9ritable interface utilisateur ni m\u00eame un rendu identique \u00e0 celui de tel ou tel connecteur. Selon le type de messages renvoy\u00e9s par le bot et selon le connecteur utilis\u00e9, il se peut que le rendu dans l'\u00e9cran Test the bot ne soit pas satisfaisant. En effet, pour une compatibilit\u00e9 parfaite avec cet \u00e9cran, les connecteurs doivent respecter certaines r\u00e8gles d'impl\u00e9mentation. Si vous constatez qu'un certain type de message pour un connecteur donn\u00e9 n'est pas bien g\u00e9r\u00e9 dans cette interface, n'h\u00e9sitez pas \u00e0 remonter une issue github . Pour parler \u00e0 un bot dans l'interface, une fois dans Test Test the bot : V\u00e9rifiez la langue (en haut \u00e0 droite de l'interface) S\u00e9lectionnez une application/un bot S\u00e9lectionnez un connecteur \u00e0 \u00e9muler Commencez \u00e0 saisir des phrases... Voici un autre exemple avec une conversation comprenant des composants riches du connecteur Messenger, avec leur rendu dans l'interface g\u00e9n\u00e9rique Tock Studio : Pour chaque \u00e9change de messages avec le bot, la langue d\u00e9tect\u00e9e est indiqu\u00e9e. En cliquant sur View Nlp Stats vous pouvez voir le d\u00e9tail de la r\u00e9ponse du mod\u00e8le : intention, entit\u00e9s, scores, etc.","title":"L'onglet Test the bot"},{"location":"user-manual/studio/test/#longlet-test-plans","text":"TODO","title":"L'onglet Test Plans"},{"location":"user-manual/studio/test/#continuer","text":"Rendez-vous dans Menu Monitoring pour la suite du manuel utilisateur. Vous pouvez aussi passer directement au chapitre suivant : D\u00e9veloppement .","title":"Continuer..."}]}